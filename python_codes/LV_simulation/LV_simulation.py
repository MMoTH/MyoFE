# -*- coding: utf-8 -*-
"""
Created on Mon Jan 10 11:15:59 2022

@author: Hossein
"""

from ast import operator
from operator import methodcaller
import os
import json
import math
import pandas as pd
import numpy as np

from dolfin import *

import time

from protocol import protocol as prot

from .dependencies.recode_dictionary import recode
from .mesh.mesh import MeshClass 
from .circulation.circulation import Circulation as circ
from .heart_rate.heart_rate import heart_rate as hr
from .dependencies.forms import Forms
from .dependencies.nsolver import NSolver
from .output_handler.output_handler import output_handler as oh
from .baroreflex import baroreflex as br
from .growth import growth as gr
from .half_sarcomere import half_sarcomere as hs 
from .fiber_reorientation import fiber_reorientation as fr
from .dependencies.assign_local_coordinate_system import assign_local_coordinate_system as lcs

from mpi4py import MPI



class LV_simulation():
    """Class for running a LV simulation using FEniCS"""

    def __init__(self,comm, instruction_data):


        # Check for model input first
        if not "model" in  instruction_data:
           return 
        self.instruction_data = instruction_data
        # Create a model dict for things that do not change during a simulation
        self.model = dict()
        # And a data dict for things that might
        self.data = dict()

        # Create the comminicator between cores
        self.comm = comm

        # Define half_sarcomere class to be used in initilizing 
        # function spaces, functions, and week form
        hs_struct = \
            instruction_data['model']['half_sarcomere']
        self.hs = hs.half_sarcomere(hs_struct)
        self.y_vec_length = len(self.hs.myof.y)

        # Initialize and define mesh objects (finite elements, 
        # function spaces, functions)
        self.mesh = MeshClass(self)

        
        # Initialize the solver object 
        #self.solver_params = self.mesh.model['solver_params']
        self.solver =  NSolver(self,self.mesh,comm)


        self.y_vec = \
            self.mesh.model['functions']['y_vec'].vector().get_local()[:]

        self.initialize_dof_mapping()
        if self.comm.Get_rank() == 0:
            print 'dof mapping on core 0'
            print self.dofmap
        self.initialize_integer_points()
        """ Create a data structure for holding """

        # half_sarcomere parameters spatially 
        # 4 comes from using degree 2
        #self.hs_params_mesh = dict()
        self.local_n_of_int_points = \
            4 * np.shape(self.mesh.model['mesh'].cells())[0]

    

        """ Calculate the total no of integration points"""
        # First on the root core
        self.global_n_of_int_points = \
            self.comm.reduce(self.local_n_of_int_points)
        # Then broadcast to all other cores
        self.global_n_of_int_points = \
            self.comm.bcast(self.global_n_of_int_points)

        """ Now generate a list (with len = total num of cores) """
        # that holds the num of integer points for each core
        self.int_points_per_core = \
                np.zeros(self.comm.Get_size())
        # Send local num of integer points to root core (i.e. 0)
        if self.comm.Get_rank() != 0:
            self.comm.send(self.local_n_of_int_points,dest = 0, tag = 1)
        else: # Root core recieves local num of int points from other cores
            self.int_points_per_core[0] = self.local_n_of_int_points
            for i in range(1,self.comm.Get_size()):
                self.int_points_per_core[i] = \
                    self.comm.recv(source = i, tag = 1)
        # Now broadcast the list to all cores
        self.int_points_per_core = \
            self.comm.bcast(self.int_points_per_core)

        if self.comm.Get_rank() == 1:
            print 'Total no if int points is %0.0f'\
                %self.global_n_of_int_points


        """ Generating arrays for holding half-sarcomere data"""
        # accross the mesh
        # Start with half-saromere length
        self.hs_length_list = self.mesh.hs_length_list
        # Delta half-sarcomere length
        self.delta_hs_length_list = np.zeros(self.local_n_of_int_points)
        # Active stress generated by cross-bridge cycling of myosin
        self.cb_stress_list = self.mesh.cb_stress_list
        # Passive stress in half-sarcomeres
        self.pass_stress_list = self.mesh.pass_stress_list

        """ Generating half-sarcomere object list"""
        self.hs_objs_list = []
        for i in np.arange(self.local_n_of_int_points):
            self.hs_objs_list.append(hs.half_sarcomere(hs_struct))
            #""" Assign the hs length according to what used in the mesh"""
            self.hs_objs_list[-1].data['hs_length'] = \
                self.hs_length_list[i]

            
        '''print("self.mesh.model['functions']['dolfin_functions']")
        print(self.mesh.model['functions']['dolfin_functions'])'''
        
        #### MM here we assign het params to the LV

        for kk, vv in self.mesh.model['functions']['dolfin_functions'].items():
            if kk == "cb_number_density":
                if self.comm.Get_rank() == 0:  
                    print("cb altered in hs_objs")
                    print("k=",kk)

                cb_inf = 0 
                for i in np.arange(self.local_n_of_int_points):
                    self.hs_objs_list[i].myof.data[kk] = self.mesh.model['functions']['dolfin_functions']['cb_number_density'][-1].vector().get_local()[i]

                       
                    if self.mesh.model['functions']['dolfin_functions']['cb_number_density'][-1].vector().get_local()[i] == 0:
                        cb_inf = cb_inf +1
                print("cb_inf")    
                print(cb_inf)

            if kk == "k_1":
                if self.comm.Get_rank() == 0:  
                    print("k_1 altered in hs_objs")
                    print("k=",kk)
                for i in np.arange(self.local_n_of_int_points):
                    self.hs_objs_list[i].myof.data[kk] = self.mesh.model['functions']['dolfin_functions']['k_1'][-1].vector().get_local()[i]
                    
            if kk == "k_on":
                if self.comm.Get_rank() == 0:  
                    print("k_on altered in hs_objs")
                    print("k=",kk)
                for i in np.arange(self.local_n_of_int_points):
                    self.hs_objs_list[i].myof.data[kk] = self.mesh.model['functions']['dolfin_functions']['k_on'][-1].vector().get_local()[i]
                    




        """ Handle the coordinates of quadrature (integer) points"""
        gdim = self.mesh.model['mesh'].geometry().dim()

        self.coord = self.mesh.model['function_spaces']['quadrature_space'].\
                tabulate_dof_coordinates().reshape((-1, gdim))
        if self.comm.Get_rank()!=0:
                self.comm.send(self.coord,dest=0,tag = 3)
        else:
            for i in range(1,self.comm.Get_size()):
                self.coord = \
                        np.append(self.coord,
                            self.comm.recv(source = i, tag = 3),axis = 0)


        self.handle_coordinates_of_geometry()

        
        
        self.handle_apex_contractility(instruction_data)

        
        self.handle_hs_visualization_on_mesh()

        #now build an array for storing radius of apex for local integer points
        self.apex_r_local = np.zeros(self.local_n_of_int_points)
        for i,j in enumerate(self.dofmap):
            self.apex_r_local[i] = self.apex_r[j]

        # Now start selecting the points and change the active properties
        if 'apex_contractility' in instruction_data['mesh']:
            apex_components = []
            for ci,comp in enumerate(instruction_data['mesh']['apex_contractility']['components']):
                apex_components.append(dict())
                for k in comp.keys():
                    apex_components[ci][k] = comp[k][0]
            
                # then apply
                indicies = np.where(self.apex_r<self.apex_r.max()*\
                    apex_components[ci]['radius_ratio'])

                mask = np.isin(self.dofmap,indicies)
                hs_list = np.array(self.hs_objs_list)

                for i,j  in enumerate(hs_list[mask]):
                    r = self.apex_r_local[mask][i]
                    if apex_components[ci]['level']=='myofilaments':
                        #j.myof.data[apex_components[ci]['variable']] *= \
                        #    apex_components[ci]['factor']
                        p = j.myof.data[apex_components[ci]['variable']]
                        j.myof.data[apex_components[ci]['variable']] = \
                            p * (1-apex_components[ci]['factor']) * r / \
                                (self.apex_r.max()*apex_components[ci]['radius_ratio']) + \
                                   p * apex_components[ci]['factor']
                    elif apex_components[ci]['level']=='memberanes':
                        #j.memb.data[apex_components[ci]['variable']] *= \
                        #    apex_components[ci]['factor']
                        p = j.memb.data[apex_components[ci]['variable']]
                        j.memb.data[apex_components[ci]['variable']] = \
                            p * (1-apex_components[ci]['factor']) * r / \
                                (self.apex_r.max()*apex_components[ci]['radius_ratio']) + \
                                   p * apex_components[ci]['factor']
######### MM note
## below loop is not overriding het assignment stuff since hs_obj is assigned sooner


        # assign the values from the half-sarcomere isntances
        # to spatial variables that baroreflex can regulate
        # (for visualizaton purpose)

        
        for p in ['k_1','k_3','k_on','cb_number_density','k_cb'] :
        #for p in ['k_1','k_3','k_on','k_cb'] :   
            for i, h in enumerate(self.hs_objs_list):
                self.mesh.data[p][i] = h.myof.data[p]
            self.mesh.model['functions'][p].vector()[:] = \
                  self.mesh.data[p]
        for p in ['k_act','k_serca']:
            for i, h in enumerate(self.hs_objs_list):
                self.mesh.data[p][i] = h.memb.data[p]
            self.mesh.model['functions'][p].vector()[:] = \
                  self.mesh.data[p]

 
        rank_id = self.comm.Get_rank()
        print '%0.0f integer points have been assigned to core %0.0f'\
             %(self.local_n_of_int_points,rank_id)
        self.local_n_of_elements = self.mesh.model['mesh'].num_cells()
        self.global_n_of_elements = \
            self.comm.reduce(self.local_n_of_elements)
        # Then broadcast to all other cores
        self.global_n_of_elements = \
            self.comm.bcast(self.global_n_of_elements)
        if self.comm.Get_rank() == 0:
            print 'Mesh contains %0.0f elements' %(self.global_n_of_elements)
        """ Create a circulatory system object"""
        circ_struct = instruction_data['model']['circulation']
        self.circ = circ(circ_struct,self.mesh)
        self.reference_LV_vol = self.circ.data['v'][-1]

        if self.comm.Get_rank() == 0:
            print self.circ.data['v']

        self.data['myocardium_vol'] = \
            assemble(1.0*dx(domain = self.mesh.model['mesh']), 
                    form_compiler_parameters={"representation":"uflacs"})
        """ Create a heart-rate object"""
        hr_struct = instruction_data['heart_rate']
        self.hr = hr(hr_struct)
        self.data['heart_rate'] = \
            self.hr.return_heart_rate()
        
        """ Initialize simulation time and counter"""
        self.data['time'] = 0
        self.data['new_beat'] = 0
        self.t_counter = 0
        self.end_diastolic = 0


        """ If requried, create the baroreceptor"""
        self.data['baroreflex_active'] = 0
        self.data['baroreflex_setpoint'] = 0
        if ('baroreflex' in instruction_data['model']):
            self.br = br.baroreflex(instruction_data['model']['baroreflex'],
                                    self,
                                    self.circ.data['pressure_arteries'])
        else:
            self.br = []
        # If required, create the growth object
        if 'growth' in instruction_data['model']:
            if self.comm.Get_rank() == 0:
                print 'Initializing growth module'
            self.gr = gr.growth(instruction_data['model']['growth'],
                                self)
        else:
            self.gr = [] 
        # If required, create the vad object
        self.va = []


        """ If requried, create the fiber reorientation"""
        
        if ('fiber_reorientation' in instruction_data['model']):
            self.fr = fr.fiber_reorientation(self)
        else:
            self.fr = []



        
        self.infarct = 0
        self.infarct_regions = [] 
        self.border_zone_regions = []
        if 'infarct' in instruction_data['mesh']:
            if self.comm.Get_rank() == 0:
                print 'Initializing infarct module'
            self.infarct = 1

        ## container for fiber reorientation_ hardcoded as was not working in initialization
        # for num of time step here  instruction is used not prot(modeling protocol) as it prot is not defined yet (def in run simulation)
        # to include initial fiber as zero time step, size of below mattrix is no_of_time_steps+1
        self.f0_vs_time_array = np.zeros((self.global_n_of_int_points,3,int(instruction_data['protocol']['no_of_time_steps'][0])+1))
        self.fdiff_mag = []    
        self.fdiff_ang = [] 
        self.f0_mag = [] 


        """self.mesh.model['functions']['LVCavityvol'].vol = \
            self.mesh.model['uflforms'].LVcavityvol()
        lv_vol = self.mesh.model['uflforms'].LVcavityvol()
        #lv_p = 0.0075*self.mesh.model['uflforms'].LVcavitypressure()
        expression_vol = self.mesh.model['functions']['LVCavityvol'].vol 
                        
        if self.comm.Get_rank() == 0: 
            print 'lv vol right before starting'
            print lv_vol
            print "expression vol before starting"
            print expression_vol
                            
        self.solver.solvenonlinear()"""

        self.sff_tracker = []
        Sff = project(self.mesh.model['functions']['Sff'], 
                    self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]
        self.data['sff_mean']= Sff

        self.data['alpha_f'] = project(self.mesh.model['functions']['alpha_f'], 
                    self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]
        inner_p = inner(self.mesh.model['functions']['f0'],
                        self.mesh.model['functions']['total_stress']*\
                            self.mesh.model['functions']['f0'])

        #total_stress = project(inner_p,self.mesh.model['function_spaces']['growth_scalar_FS'],
        #                    form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]   
        #self.data['total_stress_spatial'] = total_stress
    def create_data_structure(self,no_of_data_points, frequency = 1):
        """ returns a data frame from the data dicts of each component """

        # First build up the field data
        # Prune some fields from the self_data
        sk = []
        for k in self.circ.data.keys():
            if (k not in ['p','v','s','compliance','resistance','f']):
                sk.append(k)

        data_fields = sk + \
            list(self.data.keys()) + \
            list(self.hr.data.keys()) 
            #list(self.circ.data.keys()) 
            #list(self.hs.data.keys()) + \
            #list(self.hs.memb.data.keys()) + \
            #list(self.hs.myof.data.keys()) + \
            #['write_mode']

        # Add in fields from optional modules
        if (self.br != []):
            data_fields = data_fields + list(self.br.data.keys())
        
        if self.gr: 
            for f in list(self.gr.data.keys()):
                if f.split('_')[-1] == 'active':
                    data_fields.append(f)

        if (self.va != []):
            data_fields = data_fields + list(self.va.data.keys())
        if (self.fr != []):
            data_fields = data_fields + list(self.fr.data.keys())
        # Now start define the data holder
        rows = int(no_of_data_points/frequency) + 1 # 1 for time zero
        #sim_data = pd.DataFrame()
        #z = np.zeros(no_of_data_points)

        sim_data = dict()
        for f in data_fields:
            #print f
            sim_data[f] = np.zeros(rows)
            #s = pd.Series(data=z, name=f)
            #sim_data = pd.concat([sim_data, s], axis=1)

        return sim_data

    def create_data_structure_for_spatial_variables(self,no_of_data_points, 
                                                    num_of_int_points, 
                                                    spatial_data_fields = [],
                                                    in_average = False,
                                                    frequency = 1):
        """ return a data structure for each spatial variables, specially for MyoSim parameters"""
        if self.comm.Get_rank() == 0:
            print 'creating spatial sim data'
        
        rows = int(no_of_data_points/frequency) +1 # 1 for time zero
        i = np.zeros(rows)
        c = np.arange(num_of_int_points)

        data_field = []
        self.spatial_myof_data_fields = []
        self.spatial_memb_data_fields = []
        self.spatial_hs_data_fields = []

        self.spatial_fiber_data_fields = []

        self.spatial_gr_data_fields = []

        self.spatial_extra = []


        if spatial_data_fields:
            # create data fileds based on what user has asked
            print('data fields used from json')
            for sd in spatial_data_fields:
                if sd['level'][0] == 'half_sarcomeres':
                    for f in sd['fields']:
                        self.spatial_hs_data_fields.append(f)   
                if sd['level'][0] == 'myofilaments':
                    for f in sd['fields']:
                        self.spatial_myof_data_fields.append(f)
                if sd['level'][0] == 'membranes':
                    for f in sd['fields']:
                        self.spatial_memb_data_fields.append(f)
                if sd['level'][0] == 'fiber':
                    for f in sd['fields']:
                        self.spatial_fiber_data_fields.append(f)
        else:
            # create default data fields
            self.spatial_hs_data_fields = list(self.hs.data.keys())
            self.spatial_myof_data_fields = list(self.hs.myof.data.keys())#['M_SRX','M_DRX','M_FG','n_off','n_on','n_overlap',
                                                #'n_bound']
            self.spatial_memb_data_fields = list(self.hs.memb.data.keys())#['Ca_cytosol','Ca_SR']


            for f in ['f01','f02','f03','s01','s02','s03','n01','n02','n03','lx','ly','lz','endo_dist',
                      'eccx','eccy','eccz','errx','erry','errz','ellx','elly','ellz', 'fr_angle']:
                self.spatial_fiber_data_fields.append(f)

            for f in ['active_stress','total_passive','myofiber_passive','Sff_mesh','bulk_passive','incomp_stress']:
                self.spatial_extra.append(f)
            
            

        data_field = self.spatial_hs_data_fields +\
                        self.spatial_myof_data_fields+\
                            self.spatial_memb_data_fields+\
                            self.spatial_fiber_data_fields+\
                            self.spatial_extra
                            

        if (self.gr != [] ):
            
            for k in self.gr.data.keys():
                if k in ['gr_local_theta_fiber','gr_global_theta_fiber','gr_stimulus_fiber','gr_setpoint_fiber','gr_deviation_fiber',
                        'gr_local_theta_sheet','gr_global_theta_sheet','gr_stimulus_sheet','gr_setpoint_sheet','gr_deviation_sheet',
                        'gr_local_theta_sheet_normal','gr_global_theta_sheet_normal','gr_setpoint_sheet_normal',
                        'gr_stimulus_sheet_normal','gr_deviation_sheet_normal',]:
    
                    self.spatial_gr_data_fields.append(k)

        data_field = self.spatial_hs_data_fields +\
                        self.spatial_myof_data_fields+\
                        self.spatial_memb_data_fields+ \
                        self.spatial_fiber_data_fields+ \
                        self.spatial_gr_data_fields+\
                            self.spatial_extra

        if in_average:
            spatial_data = pd.DataFrame()
            data_field.append('time')
            data_field = data_field + ['Sff','sff_mean','alpha_f','total_stress_spatial']

            for f in data_field:
                s = pd.Series(data=np.zeros(rows), name=f)
                spatial_data = pd.concat([spatial_data, s], axis=1)
                #spatial_data[f]['time'] = pd.Series()
            
        else:
            spatial_data = dict()
            for f in data_field:
                spatial_data[f] = pd.DataFrame(0,index = i,columns=c)
            for f in ['Sff','sff_mean','alpha_f','total_stress_spatial']:
                spatial_data[f] = pd.DataFrame(0,index = i,columns=c)
                #spatial_data[f]['time'] = pd.Series(0)
        if self.comm.Get_rank() == 0:
            print 'spatial simulation data is created'

        return spatial_data

    def run_simulation(self,protocol_struct,output_struct=[]):

        self.prot = prot.protocol(protocol_struct)

        self.l_f00 = self.mesh.model['functions']['f00'].vector().get_local()[:] # this should be localized here sice at the end to time loop this function space also reorients automatially. to save initial fiber it should be saved here


        # First setup the protocol for creating output data holders
        spatial_data_fields = []
        self.spatial_data_to_mean = False
        self.dumping_data_frequency = 1
        if output_struct:
            if 'spatial_data_fields' in output_struct:
                spatial_data_fields = output_struct['spatial_data_fields']
            if 'dumping_spatial_in_average' in output_struct:
                if output_struct['dumping_spatial_in_average'][0] == True:
                    self.spatial_data_to_mean = True
            if 'frequency_n' in output_struct:
                self.dumping_data_frequency = \
                    output_struct['frequency_n'][0]


        # Define simulation data holders for storing 
        # 1-D variables (pressure, volume, etc.)
        if self.comm.Get_rank() == 0:
            self.sim_data = \
                    self.create_data_structure(self.prot.data['no_of_time_steps'],
                                                frequency = self.dumping_data_frequency )

        # Now define data holder for spatial variables.
        # Create local data holders for spatial varibles on each core
        self.local_spatial_sim_data = \
            self.create_data_structure_for_spatial_variables(self.prot.data['no_of_time_steps'],
                                                                self.local_n_of_int_points,
                                                                spatial_data_fields = spatial_data_fields,
                                                                in_average = self.spatial_data_to_mean,
                                                                frequency = self.dumping_data_frequency)
        # Create a global data holder for spatial variables 
        # on root core (i.e. 0)
        if self.comm.Get_rank() == 0:
            self.spatial_sim_data = \
                self.create_data_structure_for_spatial_variables(self.prot.data['no_of_time_steps'],
                                                                self.global_n_of_int_points,
                                                                spatial_data_fields = spatial_data_fields,
                                                                in_average = self.spatial_data_to_mean,
                                                                frequency = self.dumping_data_frequency)
        # Step through the simulation
        self.t_counter = 0
        self.write_counter = 0
        self.envelope_counter = 0

        # Initilize the output mesh files if any
        self.total_disp_file = [] 
        self.output_data_str = [] 
        self.mesh_obj_to_save = []
        if output_struct:
            if 'mesh_output_path' in output_struct:
                mesh_out_path = output_struct['mesh_output_path'][0]
                # Cehck the output path
                if self.comm.Get_rank() == 0:
                    self.check_output_directory_folder(path = mesh_out_path)
                
                if "mesh_object_to_save" in output_struct:
                    if self.comm.Get_rank() == 0:
                        print 'mesh obj is defined'
                    self.mesh_obj_to_save = output_struct['mesh_object_to_save']
                    # start creating file for mesh objects
                    file_path = os.path.join(mesh_out_path,'solution.xdmf') 
                    self.solution_mesh = XDMFFile(mpi_comm_world(),file_path)
                    self.solution_mesh.parameters.update({"functions_share_mesh": True,
                                            "rewrite_function_mesh": False})

                    
                    Quadelem = FiniteElement("Quadrature", tetrahedron, degree=2, quad_scheme="default")
                    Quadelem._quad_scheme = 'default'
                    Quad = FunctionSpace(self.mesh.model['mesh'], Quadelem)

                    FE_DG0 = FiniteElement("DG",self.mesh.model['mesh'].ufl_cell(),0)
                    FS_DG0 = FunctionSpace(self.mesh.model['mesh'],FE_DG0)

                    # if multiple cores are being used then save
                    # a mesh object to visualize core assignments
                    if self.comm.Get_size()>1:
                        self.mesh_path_for_mpi = mesh_out_path
                        xdmf = XDMFFile(mesh_out_path+"/mesh_with_mpi" + ".xdmf")
                        xdmf.write(self.mesh.model['functions']['core_ranks'])
                        xdmf.close()


                    for m in self.mesh_obj_to_save:
                        if m == 'displacement':
                            temp_obj = self.mesh.model['functions']['w'].sub(0)
                        if m == 'hs_length':
                            temp_obj = project(self.mesh.model['functions']['hsl'], 
                                                self.mesh.model['function_spaces']["scalar"],
                                                form_compiler_parameters={"representation":"uflacs"})
                        
                       

                        if m in ['k_1','k_3','k_on','k_act','k_serca']:
                            temp_obj = project(self.mesh.model['functions'][m], 
                                                self.mesh.model['function_spaces']["scalar"])

                            

                        if m in ['k_1_DG0']:
                            temp_obj = project(self.mesh.model['functions']["k_1"], 
                                                FS_DG0)
                            
                        if m == 'cb_number_density_DG0':
                            temp_obj = project(self.mesh.model['functions']["cb_number_density"], 
                                                FS_DG0)

                        if m == 'cb_number_density':
                            temp_obj = project(self.mesh.model['functions']["cb_number_density"], 
                                                self.mesh.model['function_spaces']["scalar"])



                        if m == 'active_stress':
                            temp_obj = project(inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['Pactive']*
                                        self.mesh.model['functions']['f0']),
                                        self.mesh.model['function_spaces']["scalar"],
                                        form_compiler_parameters={"representation":"uflacs"})
                            

                        if m == 'active_stress_DG0':
                            temp_obj = project(inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['Pactive']*
                                        self.mesh.model['functions']['f0']),
                                        FS_DG0,form_compiler_parameters={"representation":"uflacs"})
                            

                        if m == 'reorienting_angle':

                            fdiff_ang= Function(Quad)   
                            finite_element_R0 = FiniteElement("DG",self.mesh.model['mesh'].ufl_cell(),0)
                            finite_elemet_R00 = FunctionSpace(self.mesh.model['mesh'],finite_element_R0)

                            temp_obj = project(fdiff_ang,finite_elemet_R00)

    
                        if m == 'c_param_DG0':

                            temp_obj = project(self.mesh.model['functions']['dolfin_functions']["passive_params"]["c"][-1],FS_DG0)
                            #File(self.instruction_data["output_handler"]['mesh_output_path'][0] + "c_param.pvd") << project(self.mesh.model['functions']['dolfin_functions']["passive_params"]["c"][-1],FunctionSpace(self.mesh.model['mesh'],"DG",0))

                        if m == 'c_param':
                            temp_obj = project(self.mesh.model['functions']['dolfin_functions']["passive_params"]["c"][-1],self.mesh.model['function_spaces']["scalar_CG"])
                        
  
                        if m == 'fiber_direction':
                            
                            Velem0 = VectorElement("CG",self.mesh.model['mesh'].ufl_cell(), 1, quad_scheme="default")
                            Velem0._quad_scheme = 'default'
                            Velem_FS = FunctionSpace(self.mesh.model['mesh'],Velem0)
                            temp_obj = project(self.mesh.model['functions']['f0'],Velem_FS)


                        if m == 'endo_distance':

                            temp_obj =  project(self.mesh.model['functions']['endo_dist'],self.mesh.model['function_spaces']["scalar"])

                        if m == 'Transverse_Angle':

                            self.TA= Function(Quad) 
                            temp = np.einsum('ij,ij->i',self.mesh.model['functions']['f0'].vector().array().reshape((-1,3)),self.mesh.model['functions']['ell'].vector().array().reshape((-1,3)))
                            temp2 = np.einsum('ij,ij->i',self.mesh.model['functions']['f0'].vector().array().reshape((-1,3)),self.mesh.model['functions']['ecc'].vector().array().reshape((-1,3)))
                            temp3 = np.einsum('ij,ij->i',self.mesh.model['functions']['f0'].vector().array().reshape((-1,3)),self.mesh.model['functions']['err'].vector().array().reshape((-1,3)))
                            self.TA.vector()[:] = (180/np.pi)*(np.arctan(temp3/temp2))

                            temp_obj =  project(self.TA,FS_DG0)


                
                        if m == 'Helical_Angle':

                            self.HA= Function(Quad) 
                            temp = np.einsum('ij,ij->i',self.mesh.model['functions']['f0'].vector().array().reshape((-1,3)),self.mesh.model['functions']['ell'].vector().array().reshape((-1,3)))
                            temp2 = np.einsum('ij,ij->i',self.mesh.model['functions']['f0'].vector().array().reshape((-1,3)),self.mesh.model['functions']['ecc'].vector().array().reshape((-1,3)))
                            temp3 = np.einsum('ij,ij->i',self.mesh.model['functions']['f0'].vector().array().reshape((-1,3)),self.mesh.model['functions']['err'].vector().array().reshape((-1,3)))
                            self.HA.vector()[:]  = (180/np.pi)*(np.arctan(temp/temp2))

                            temp_obj =  project(self.HA,FS_DG0)
                        

                        if m == 'total_stress':
                            temp_obj = project(inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['total_stress']*
                                        self.mesh.model['functions']['f0']),
                                        self.mesh.model['function_spaces']["scalar"],
                                        form_compiler_parameters={"representation":"uflacs"})
                            
                        if m == 'total_stress_vector':

                            Velem0 = VectorElement("CG",self.mesh.model['mesh'].ufl_cell(), 1, quad_scheme="default")
                            Velem0._quad_scheme = 'default'
                            Velem_FS = FunctionSpace(self.mesh.model['mesh'],Velem0)

                            temp_obj = project((self.mesh.model['functions']['total_stress']*self.mesh.model['functions']['f0']),Velem_FS,
                                        form_compiler_parameters={"representation":"uflacs"})
                            
                        if m == 'total_passive':
                            temp_obj = project(inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['total_passive_PK2']*
                                        self.mesh.model['functions']['f0']),
                                        self.mesh.model['function_spaces']["scalar_for_active"],
                                        form_compiler_parameters={"representation":"uflacs"})
                        if m == 'myofiber_passive':
                            temp_obj = project(inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['Sff']*
                                        self.mesh.model['functions']['f0']),
                                        self.mesh.model['function_spaces']["scalar_for_active"],
                                        form_compiler_parameters={"representation":"uflacs"})


                        if m in ['local_theta_vis_fiber','local_theta_vis_sheet','local_theta_vis_sheet_normal',
                                'global_theta_vis_fiber','global_theta_vis_sheet','global_theta_vis_sheet_normal'
                                'stimulus_fiber', 'stimulus_sheet', 'stimulus_sheet_normal',
                                'deviation_fiber', 'deviation_sheet','deviation_sheet_normal',
                                'setpoint_fiber','setpoint_sheet','setpoint_sheet_normal'] and \
                                    'growth' in self.instruction_data['model']:

                                temp_obj = project(self.mesh.model['functions'][m],
                                                self.mesh.model['function_spaces']["scalar_for_growth"],
                                                form_compiler_parameters={"representation":"uflacs"})

                        

                        if m == 'facetboundaries':
                            xdmf = XDMFFile(mesh_out_path+"/facet_boundaries" + ".xdmf")
                            xdmf.write(self.mesh.model['functions']['facetboundaries'])
                            xdmf.close()
                        else:
                            temp_obj.rename(m,'')
                            self.solution_mesh.write(temp_obj,0)

            if 'growth_mesh_path' in output_struct:
                # create mesh object and visualize the growth of reference config
                path = output_struct['growth_mesh_path'][0]
                self.growth_path = path
                file_path = os.path.join(path,'growth.xdmf')

                self.growth_mesh = XDMFFile(mpi_comm_world(),file_path)
                self.growth_mesh.parameters.update({"functions_share_mesh": True,
                                            "rewrite_function_mesh": True})
                #temp_obj = self.mesh.model['functions']['w'].sub(0)
                #temp_obj.rename('Dis','')
                self.growth_mesh.write(self.mesh.model['mesh'],0)


            if 'output_data_path' in output_struct:
                self.output_data_str = output_struct['output_data_path'][0]
                if self.comm.Get_rank() == 0: 
                    self.check_output_directory_folder(path = self.output_data_str)
            
        for i in np.arange(self.prot.data['no_of_time_steps']+1):
            #self.implement_time_step(self.prot.data['time_step'])
            try:
                self.implement_time_step(self.prot.data['time_step'])
            except RuntimeError: 
                print "RuntimeError happend"
                self.handle_output(output_struct)
                return
        
        
        

        # Now build up global data holders for 
        # spatial variables if multiple cores have been used
        self.handle_output(output_struct)
       

    def implement_time_step(self, time_step):
        """ Implements time step """
        
        if self.comm.Get_rank() == 0:
            print '******** NEW TIME STEP ********'
            print (self.data['time'])
            print 'Myocardium Vol is: %f' %self.data['myocardium_vol']
        
            if (self.t_counter % 10 == 0):
                print('Sim time (s): %.00f  %.0f%% complete' %
                    (self.data['time'],
                    100*self.t_counter/self.prot.data['no_of_time_steps']))

                vol, press, flow = self.return_system_values()
                

                print(json.dumps(vol, indent=4))
                print(json.dumps(press, indent=4))
                print(json.dumps(flow, indent=4))
        
        # Update circulation and FE function for LV cavity volume
        self.circ.data['v'] = \
                self.circ.evolve_volume(time_step, self.circ.data['v'])

        #update regurgitant volvumes
        reg_volumes = self.circ.evolve_regurgitant_volumes(time_step, self.circ.data['v'])
        self.circ.data['mitral_reg_volume'] = reg_volumes[0]
        self.circ.data['aortic_reg_volume'] = reg_volumes[-1]

        # Check for baroreflex and implement
        if (self.br):
            self.data['baroreflex_active'] = 0
            for b in self.prot.baro_activations:
                if ((self.t_counter >= b.data['t_start_ind']) and
                        (self.t_counter < b.data['t_stop_ind'])):
                    self.data['baroreflex_active'] = 1




            self.br.implement_time_step(self.circ.data['pressure_arteries'],
                                        time_step,
                                        reflex_active=
                                        self.data['baroreflex_active'])

            #now update the function for spatial controlled parameters  
            for p in ['k_1','k_3','k_on','k_act','k_serca']:
                self.mesh.model['functions'][p].vector()[:] = \
                  self.mesh.data[p]


        


        self.data['myocardium_vol'] = \
            assemble(1.0*dx(domain = self.mesh.model['mesh']), 
                    form_compiler_parameters={"representation":"uflacs"})

        # check for any perturbation
        for p in self.prot.perturbations:
            if (self.t_counter >= p.data['t_start_ind'] and 
                self.t_counter < p.data['t_stop_ind']):
                if 'increment' in  p.data.keys():
                    if p.data['level'] == 'circulation':
                        self.circ.data[p.data['variable']] += \
                            p.data['increment']
                    elif p.data['level'] == 'baroreflex':
                        self.br.data[p.data['variable']] += \
                            p.data['increment']

                    elif p.data['level'] == 'fiber_reorientation':
                        self.fr.data[p.data['variable']] += \
                        p.data['increment']


                    elif p.data['level'] == 'myofilaments':
                        for j in range(self.local_n_of_int_points):
                            self.hs_objs_list[j].myof.data[p.data['variable']] +=\
                                p.data['increment']
                    elif p.data['level'] == 'membranes':
                        for j in range(self.local_n_of_int_points):
                            self.hs_objs_list[j].memb.data[p.data['variable']] +=\
                                p.data['increment']
                elif 'precentage_change' in p.data.keys():
                    if p.data['level'] == 'growth':
                        self.gr.data[p.data['variable']] += \
                            self.gr.data[p.data['variable']] * p.data['precentage_change']



        if self.infarct: 
            for i in self.prot.infarct_activation:
                if (self.t_counter >= i.data['t_start_ind'] and 
                    self.t_counter < i.data['t_stop_ind']):
                    if self.t_counter == i.data['t_start_ind']:
                        self.infarct_regions, self.border_zone_regions = \
                            self.handle_infarct(self.instruction_data['mesh']['infarct'])
                    if self.infarct_model['level']== 'myofilaments':
                        for r in self.infarct_regions:
                            self.hs_objs_list[r].myof.data[self.infarct_model['variable']] +=\
                                i.data['infarct_increment']

                            #print self.hs_objs_list[r].myof.data[self.infarct.model['variable']]
                        
                        for b in self.border_zone_regions:
                            self.hs_objs_list[b].myof.data[self.infarct_model['variable']] +=\
                                i.data['boundary_zone_increment']

                    elif self.infarct_model['level'] == 'membranes':
                        for r in self.infarct_regions:
                            self.hs_objs_list[r].memb.data[self.infarct_model['variable']] +=\
                                i.data['infarct_increment']
                        for b in self.border_zone_regions:
                            self.hs_objs_list[b].memb.data[self.infarct_model['variable']] +=\
                                i.data['boundary_zone_increment']
                            


                    '''elif self.infarct_model['level'] == 'chronic':
                        for r in self.infarct_regions:
                            self.hs_objs_list[r].memb.data[self.infarct_model['variable']] +=\
                                i.data['infarct_increment']
                            

                            dolfin_functions["passive_params"][k][-1].vector()[jj] = base_value*scaling_factor
                            dolfin_functions["passive_params"]["bt"][-1].vector()[jj] = 8
                            dolfin_functions["passive_params"]["bf"][-1].vector()[jj] = 10
                            dolfin_functions["passive_params"]["bfs"][-1].vector()[jj] = 10
                            dolfin_functions["cb_number_density"][-1].vector()[jj] = 0
                            
                        for b in self.border_zone_regions:
                            self.hs_objs_list[b].memb.data[self.infarct_model['variable']] +=\
                                i.data['boundary_zone_increment']'''
        
        # Rubild system arrays
        self.rebuild_from_perturbations()
        # Proceed time
        (activation, new_beat,self.end_diastolic) = \
            self.hr.implement_time_step(time_step)

        if self.comm.Get_rank() == 0:
            # Solve MyoSim ODEs across the mesh
            print 'Solving MyoSim ODEs across the mesh'
        start = time.time()

        
        for j in range(self.local_n_of_int_points):
            
            #for p in ['k_1','k_3','k_on'] :
                ##MM note: below is overriding het stuff
            for p in ['k_1','k_3','k_on','cb_number_density'] :
                self.mesh.data[p][j] = self.hs_objs_list[j].myof.data[p]
                   
            for p in ['k_act','k_serca']:
                self.mesh.data[p][j] = self.hs_objs_list[j].memb.data[p]

            self.hs_objs_list[j].update_simulation(time_step, 
                                                self.delta_hs_length_list[j], 
                                                activation,
                                                self.cb_stress_list[j],
                                                self.pass_stress_list[j])
            self.hs_objs_list[j].update_data()
            
            if j%1000==0 and self.comm.Get_rank() == 0:
                print '%.0f%% of integer points are updated' % (100*j/self.local_n_of_int_points)
            self.y_vec[j*self.y_vec_length+np.arange(self.y_vec_length)]= \
                self.hs_objs_list[j].myof.y[:]
            


        end =time.time()
        
    

        for p in ['k_1','k_3','k_on','cb_number_density','k_act','k_serca'] :
            self.mesh.model['functions'][p].vector()[:] = \
                  self.mesh.data[p]
                
        if self.comm.Get_rank() == 0:
            print 'Required time for solving myosim was'
            t = end-start 
            print t

        # Now update fenics FE for population array (y_vec) and hs_length
        self.mesh.model['functions']['y_vec'].vector()[:] = self.y_vec
        self.mesh.model['functions']['hsl_old'].vector()[:] = self.hs_length_list


        # Update LV cavity volume fenics function        
        self.mesh.model['functions']['LVCavityvol'].vol = \
            self.circ.data['v'][-1]

        self.comm.Barrier()
        #Solve cardiac mechanics weak form
        #--------------------------------
        if self.comm.Get_rank() == 0:
            print 'solving weak form'
        self.solver.solvenonlinear()
        

        # Start updating variables after solving the weak form 
        # First pressure in circulation
        for i in range(self.circ.model['no_of_compartments']-1):
            self.circ.data['p'][i] = (self.circ.data['v'][i] - self.circ.data['s'][i]) / \
                    self.circ.data['compliance'][i]
        # 0.0075 is for converting to mm Hg
        self.circ.data['p'][-1] = \
                0.0075*self.mesh.model['uflforms'].LVcavitypressure()

        # Then update FE function for cross-bridge stress, hs_length, and passive stress
        # across the mesh
        self.cb_stress_list = project(self.mesh.model['functions']['cb_stress'],
                                self.mesh.model['function_spaces']['quadrature_space']).vector().get_local()[:]

        self.mesh.model['functions']['hsl_old'].vector()[:] = \
            project(self.mesh.model['functions']['hsl'], 
            self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]

        new_hs_length_list = \
            project(self.mesh.model['functions']['hsl'], 
            self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]

        self.delta_hs_length_list = new_hs_length_list - self.hs_length_list
        self.hs_length_list = new_hs_length_list
        
        #self.mesh.model['functions']['myofiber_stretch'].vector()[self.mesh.model['functions']['myofiber_stretch'].vector()<1.0]=1.0

        temp_DG = project(self.mesh.model['functions']['Sff'], 
                    FunctionSpace(self.mesh.model['mesh'], "DG", 1), 
                    form_compiler_parameters={"representation":"uflacs"})

        p_f = interpolate(temp_DG, self.mesh.model['function_spaces']["quadrature_space"])
        self.pass_stress_list = p_f.vector().get_local()[:]
        
        # Convert negative passive stress in half-sarcomeres to 0
        self.pass_stress_list[self.pass_stress_list<0] = 0

        self.comm.Barrier()
        # Update sim data for non-spatial variables on root core (i.e. 0)
        """###############"""
        # check Sff
        if self.comm.Get_rank() == 0:
            print 'Checking Sff values'
        Sff = project(self.mesh.model['functions']['Sff'], 
                    self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]

        inner_p = inner(self.mesh.model['functions']['f0'],
                        self.mesh.model['functions']['total_stress']*\
                            self.mesh.model['functions']['f0'])

        #total_stress = project(inner_p,self.mesh.model['function_spaces']['growth_scalar_FS'],
        #                    form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]   
        
        neg_sff = np.array(Sff[Sff<0])
        num_of_neg_sff = len(neg_sff)
        self.data['Sff'] = Sff
        print 'Core: %d, num of points with negative Sff:%d' %(self.comm.Get_rank(),num_of_neg_sff)

        #self.data['total_stress_spatial'] = total_stress
        self.sff_tracker.append(Sff)
        """###############"""
        """###############"""
        if self.end_diastolic:
            self.data['sff_mean'] = np.mean(self.sff_tracker,axis=0)
            neg_ind_local = np.where(self.data['sff_mean']<0)[0]
            neg_ind_global = self.dofmap[neg_ind_local]
            z_neg_sff = self.z_coord[neg_ind_global]
            #print 'z_neg_sff'
            #print z_neg_sff
            self.sff_tracker = []

        # check myofiber stretch

        #alpha_f = project(self.mesh.model['functions']['alpha_f'], 
        #            FunctionSpace(self.mesh.model['mesh'], "DG", 1), 
        #            form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]
        myo_stretch = project(self.mesh.model['functions']['myofiber_stretch'], 
                    self.mesh.model['function_spaces']['quadrature_space']).vector().get_local()[:]
        #self.data['hsl0'] = hsl0
        self.data['hsl'] = new_hs_length_list
        self.data['alpha_f'] = myo_stretch
        """if self.comm.Get_rank() == 0:
            print 'Checking myofiber stretch'
            print 'hsl:'
            print new_hs_length_list

            print 'myo_stretch:'
            print myo_stretch 
            print 'Sff:'
            print Sff """
        """###############"""
        if self.gr:            
            #self.data['growth_active'] = 0
            for g in self.prot.growth_activations:
                # Initilize indicies for growth
                # 'gr_start_active': identify the first cycle after growth is activated
                # 'gr_active': identify the activation of growth onward
                # initial_gr_cycle_counter: counter for initial growth step
                if self.t_counter == g.data['t_start_ind']:
                    self.gr.data['gr_start_active'] = 1
                    self.gr.data['gr_active'] = 0
                    self.gr.initial_gr_cycle_counter = 1

                # identify if we are not in the initial growth steps anymore
                if self.gr.initial_gr_cycle_counter > self.gr.initial_gr_cycles:
                    self.gr.data['gr_start_active'] = 0

                # Implement growth when is
                if ((self.t_counter >= g.data['t_start_ind']) and
                        (self.t_counter < g.data['t_stop_ind'])):
                    
                    if self.comm.Get_rank() == 0:
                        print 'Growth module is activated'
                    
                    # identify the cycle before happening of growth cycles for 
                    # calculating setpoint
                    self.gr.data['gr_setpoint_active'] = 0
                    if self.gr.initial_gr_cycle_counter == self.gr.initial_gr_cycles - 1:
                        self.gr.data['gr_setpoint_active'] = 1
                        self.gr.store_setpoint(self.gr.data['gr_setpoint_active'])
                        
                        # assign setpoint when it is at end diastole 
                        if self.end_diastolic:
                            self.gr.assign_setpoint()
                            self.gr.data['gr_active'] = 1
                    else: 
                         self.gr.data['gr_setpoint_active'] = 0

                    # calculate stimulus at the last cycle before hapening of growth
                    self.gr.data['gr_stimulus_active'] = 0
                    if self.gr.initial_gr_cycle_counter >= (self.gr.initial_gr_cycles - 1) and \
                        self.gr.growth_frequency_n_counter == self.gr.growth_frequency_n:
                        #print 'True for theta'
                        self.gr.data['gr_stimulus_active'] = 1

                    # implement growth, it will handle storing data and tracking the changes
                    # updating dolfin functions like 'local_thetas' and 'global_thetas'
                    self.gr.implement_growth(self.end_diastolic,time_step)
                    
                    # let's grow the geometry when thetas are calculated and time-step is
                    # at end-diastole
                    if self.end_diastolic:

                        if self.gr.growth_frequency_n_counter == self.gr.growth_frequency_n and\
                             self.gr.initial_gr_cycle_counter >= self.gr.initial_gr_cycles:

                            #print 'True for growth' 
                            # store cavity volume before growth to reload back to this vol
                            ED_vol = self.mesh.model['uflforms'].LVcavityvol()
                            if self.comm.Get_rank() == 0:
                                print 'Reference volume before growth'
                                print self.reference_LV_vol
                         

                            # update dolfin functions for thetas that Fg is defined upon
                            # Fg = theta_f(f0xf0) + theta_s(s0xs0) + theta_n(n0xn0)
                            for dir in ['fiber','sheet','sheet_normal']:
                                name = 'theta_' + dir
                                temp_name = 'temp_' + name
                                local_theta = self.gr.mechan.model['functions'][temp_name].vector().get_local()[:]
                                self.gr.mechan.model['functions'][name].vector()[:] = local_theta
                                   
                                    #self.gr.mechan.model['functions'][temp_name].vector().get_local()[:]
                                #print self.gr.mechan.model['functions'][temp_name].vector().get_local()[:]
                            """########start#######"""
                            Fg = self.gr.mechan.model['functions']['Fg']
                            Fe = self.gr.mechan.model['functions']['Fe']

                            temp_Fg = project(Fg,self.gr.mechan.model['function_spaces']['tensor_space'],
                                                form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]
                            temp_Fe = project(Fe,self.gr.mechan.model['function_spaces']['tensor_space'],
                                                form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]
                            F = self.gr.mechan.model['functions']['Fmat']
                            temp_F = project(F,self.gr.mechan.model['function_spaces']['tensor_space'],
                                                form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]
                            #print Fg
                            if self.comm.Get_rank() == 0:
                                print 'Fg after updating Fg'
                                print temp_Fg
                                print 'Fe after updating Fg'
                                print temp_Fe
                                print 'F after updating Fg'
                                print temp_F
                            """============================== """
                            #do stuff for printing Fg and Fe
                            min_Fg = temp_Fg.min()
                            max_Fg = temp_Fg.max()
                            min_Fe = temp_Fe.min()
                            max_Fe = temp_Fe.max()
                            if self.comm.Get_rank() != 0:
                                self.comm.send(min_Fg,dest = 0,tag = 10)
                                self.comm.send(max_Fg,dest = 0,tag = 11)
                                self.comm.send(min_Fe,dest = 0,tag = 12)
                                self.comm.send(max_Fe,dest = 0,tag = 13)

                            if self.comm.Get_rank() == 0:
                                min_Fg_array = [temp_Fg.min()]
                                max_Fg_array = [temp_Fg.max()]
                                min_Fe_array = [temp_Fe.min()]
                                max_Fe_array = [temp_Fe.max()]

                                for i in range(1,self.comm.Get_size()):
                                        min_Fg_array.append(self.comm.recv(source = i, tag = 10))
                                        max_Fg_array.append(self.comm.recv(source = i, tag = 11))
                                        min_Fe_array.append(self.comm.recv(source = i, tag = 12))
                                        max_Fe_array.append(self.comm.recv(source = i, tag = 13))
                            
                            if self.comm.Get_rank() == 0:
                                print 'min of Fg'
                                print np.array(min_Fg_array).min()
                                print 'max of Fg'
                                print np.array(max_Fg_array).max()
                                print 'min of Fe'
                                print np.array(min_Fe_array).min()
                                print 'max of Fe'
                                print np.array(max_Fe_array).max()

                            #do stuff for printing theta
                            for n,comp in enumerate(self.gr.components):
                                theta_name = 'gr_local_theta' + '_' +  comp.data['type']
                                min_theta = self.gr.data[theta_name].min()
                                max_theta = self.gr.data[theta_name].max()
                                j= 14 + n
                                if self.comm.Get_rank() != 0:
                                    self.comm.send(min_theta,dest = 0,tag = j+1)
                                    self.comm.send(max_theta,dest = 0,tag = j+2)
                                if self.comm.Get_rank() == 0:
                                    min_theta_array = [self.gr.data[theta_name].min()]
                                    max_theta_array = [self.gr.data[theta_name].max()]
                                    for i in range(1,self.comm.Get_size()):
                                        min_theta_array.append(self.comm.recv(source = i, tag = j+1))
                                        max_theta_array.append(self.comm.recv(source = i, tag = j+2))
                                
                                rank_of_min = 0
                                rank_of_max = 0
                                if self.comm.Get_rank() == 0:
                                    rank_of_min = np.argmin(min_theta_array)
                                    rank_of_max = np.argmax(max_theta_array)
                                rank_of_min = self.comm.bcast(rank_of_min,root=0)
                                rank_of_max = self.comm.bcast(rank_of_max,root=0)

                                if self.comm.Get_rank() == rank_of_min:
                                    index = np.argmin(self.gr.data[theta_name])
                                    report_dict = dict()
                                    report_dict['Type'] = 'Min Theta'
                                    report_dict['direction'] = comp.data['type']
                                    report_dict['Rank'] = self.comm.Get_rank()
                                    report_dict['int_point'] = index
                                    report_dict['deviation'] = self.gr.data['gr_deviation_' + comp.data['type']][index]
                                    report_dict['global_theta'] = self.gr.data['gr_global_theta_' + comp.data['type']][index]
                                    report_dict['local_theta'] = self.gr.data['gr_local_theta_' +  comp.data['type']][index]
                                    report_dict['stimulus'] = self.gr.data['gr_stimulus_'+comp.data['type']][index]
                                    report_dict['setpoint'] = self.gr.data['gr_setpoint_'+comp.data['type']][index]
                                    dofmap = self.dofmap[index]
                                    #report_dict['dofmap'] = dofmap
                                    report_dict['x_ccord'] = self.x_coord[dofmap]
                                    report_dict['y_ccord'] = self.y_coord[dofmap]
                                    report_dict['z_ccord'] = self.z_coord[dofmap]

                                    print(json.dumps(report_dict, indent=4))
                                    
                                if self.comm.Get_rank() == rank_of_max:
                                    index = np.argmin(self.gr.data[theta_name])
                                    report_dict = dict()
                                    report_dict['Type'] = 'Max Theta'
                                    report_dict['direction'] = comp.data['type']
                                    report_dict['Rank'] = self.comm.Get_rank()
                                    report_dict['int_point'] = index
                                    report_dict['deviation'] = self.gr.data['gr_deviation_' + comp.data['type']][index]
                                    report_dict['global_theta'] = self.gr.data['gr_global_theta_' + comp.data['type']][index]
                                    report_dict['local_theta'] = self.gr.data['gr_local_theta_' +  comp.data['type']][index]
                                    report_dict['stimulus'] = self.gr.data['gr_stimulus_'+comp.data['type']][index]
                                    report_dict['setpoint'] = self.gr.data['gr_setpoint_'+comp.data['type']][index]
                                    dofmap = self.dofmap[index]
                                    #report_dict['dofmap'] = dofmap
                                    report_dict['x_ccord'] = self.x_coord[dofmap]
                                    report_dict['y_ccord'] = self.y_coord[dofmap]
                                    report_dict['z_ccord'] = self.z_coord[dofmap]
                                    
                                    print(json.dumps(report_dict, indent=4))

                                n_of_min_theta = len(self.gr.data[theta_name][self.gr.data[theta_name]<0.5])
                                n_of_max_theta = len(self.gr.data[theta_name][self.gr.data[theta_name]>1.5])
                                if self.comm.Get_rank() != 0:
                                    self.comm.send(n_of_min_theta,dest = 0,tag = j+3)
                                    self.comm.send(n_of_max_theta,dest = 0,tag = j+4)
                                if self.comm.Get_rank() == 0:
                                    n_min_theta_array = [n_of_min_theta]
                                    n_max_theta_array = [n_of_max_theta]
                                    for i in range(1,self.comm.Get_size()):
                                        n_min_theta_array.append(self.comm.recv(source = i, tag = j+3))
                                        n_max_theta_array.append(self.comm.recv(source = i, tag = j+4))
                                    print 'n_min_theta_array'
                                    print n_min_theta_array
                                    print 'n_max_theta_array'
                                    print n_max_theta_array

                                n_total_min_theta = self.comm.reduce(n_of_min_theta)
                                n_total_max_theta = self.comm.reduce(n_of_max_theta)

                                n_total_min_theta = self.comm.bcast(n_total_min_theta)
                                n_total_max_theta = self.comm.bcast(n_total_max_theta)
                                if self.comm.Get_rank() == 0:
                                    print 'n_total_min_theta'
                                    print n_total_min_theta
                                    print 'n_total_max_theta'
                                    print n_total_max_theta
                                
                                
                            """============================== """
                            """#######end########"""
                            # Grow reference configuration
                            self.gr.grow_reference_config()

                            # reset Fg = 1
                            for dir in ['fiber','sheet','sheet_normal']:
                                name = 'theta_' + dir
                                self.gr.mechan.model['functions'][name].vector()[:] = 1
                            #self.update_theta_Fg()

                            # reinitialize mesh onjects everywhere
                            if self.comm.Get_rank() == 0:
                                print 'Updating Mesh class'

                            # store information for updating the reference geometry
                            predefined_functions = dict()
                            predefined_functions['facetboundaries'] = self.gr.mechan.model['functions']['facetboundaries']
                            predefined_functions['hsl0'] = self.gr.mechan.model['functions']['hsl0']
                            predefined_functions['f0'] = self.gr.mechan.model['functions']['f0']
                            predefined_functions['s0'] = self.gr.mechan.model['functions']['s0']
                            predefined_functions['n0'] = self.gr.mechan.model['functions']['n0']
                            
                            #reinitialize mesh class with the geometry from growth
                            self.mesh = MeshClass(self,predefined_mesh = self.gr.mechan.model['mesh'],
                                                    predefined_functions = predefined_functions)
                            #reinitialize growth mechanics class with the geometry from growth
                            self.gr.reinitialize_mesh_object_for_growth(predefined_functions)

                            # reinitialize solver object
                            self.solver =  NSolver(self,self.mesh,self.comm)

                            # reinitialize dof mapping
                            self.initialize_dof_mapping()
                            # reinitialize integer points
                            self.initialize_integer_points()

                            rank_id = self.comm.Get_rank()
                            print '%0.0f integer points have been assigned to core %0.0f'\
                                %(self.local_n_of_int_points,rank_id)
                            # update coordinates of nodes over updated reference geometry
                            self.handle_coordinates_of_geometry()
                            # adjust apex contractility if needed 
                            self.handle_apex_contractility(self.instruction_data)
                            # handle half-sarocomere visualization
                            self.handle_hs_visualization_on_mesh()
                            # update mesh in circulatory object 
                            self.circ.mesh = self.mesh
                        # check if the pressure is zero 
                            
                            # reset solution to zero 
                            self.mesh.model['functions']['w'].vector()[:] = 0.0
                            """#######start########"""
                            sol = self.mesh.model['functions']['w'].vector().array()[:] 
                            sol_gr = self.gr.mechan.model['functions']['w'].vector().array()[:] 
                            if self.comm.Get_rank() == 0:
                                print 'Checking solution in mesh class is reset to 0'
                                print sol
                                print 'Checking solution in gr class is reset to 0'
                                print sol_gr
                            """#######end########"""

                            # now save mesh file for reference geometry 
                            file_path = os.path.join(self.growth_path,'growth_' + str(self.data['time']) +'.xdmf') 
                            self.growth_mesh = XDMFFile(mpi_comm_world(),file_path)
                            self.growth_mesh.parameters.update({"functions_share_mesh": True,
                                                        "rewrite_function_mesh": True})
                            self.growth_mesh.write(self.mesh.model['mesh'])
                            
                            
                            """#######start########"""
                            Fg = self.gr.mechan.model['functions']['Fg']
                    
                            Fe = self.gr.mechan.model['functions']['Fe']
                                            #Fg = self.mesh.model['functions']['Fg']
                            temp_Fg = project(Fg,self.gr.mechan.model['function_spaces']['tensor_space'],
                                                form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]
                            temp_Fe = project(Fe,self.gr.mechan.model['function_spaces']['tensor_space'],
                                                form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]
                            F = self.gr.mechan.model['functions']['Fmat']
                            temp_F = project(F,self.gr.mechan.model['function_spaces']['tensor_space'],
                                            form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]
                            #E = self.mesh.model['functions']['E']
                            #temp_E = project(E,self.mesh.model['function_spaces']['tensor_space'],
                            #                form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]
                            if self.comm.Get_rank() == 0:
                                print 'Fg after reseting w'
                                print temp_Fg
                                print 'Fe after reseting w'
                                print temp_Fe
                                print 'F after reseting w'
                                print temp_F

                            """#######end########"""

                            # now reload back to ED vol
                            self.reference_LV_vol = \
                                self.mesh.model['uflforms'].LVcavityvol()
                            
                            self.mesh.model['functions']['LVCavityvol'].vol = \
                                self.mesh.model['uflforms'].LVcavityvol()
                            """#######start########"""
                            lv_vol = self.mesh.model['uflforms'].LVcavityvol()
                            #lv_p = 0.0075*self.mesh.model['uflforms'].LVcavitypressure()
                            expression_vol = self.mesh.model['functions']['LVCavityvol'].vol 
                            
                            if self.comm.Get_rank() == 0: 
                                print 'lv vol right before solve nonlinear'
                                print lv_vol
                                print "expression vol right before solve nonlinear "
                                print expression_vol
                                #print'lv press'
                                #print lv_p
                            #self.solver.solvenonlinear()

                            lv_vol = self.mesh.model['uflforms'].LVcavityvol()
                            lv_p = 0.0075*self.mesh.model['uflforms'].LVcavitypressure()
                            expression_vol = self.mesh.model['functions']['LVCavityvol'].vol 
                            
                            if self.comm.Get_rank() == 0: 
                                print 'lv vol'
                                print lv_vol
                                print "expression vol "
                                print expression_vol
                                print'lv press'
                                print lv_p
                            """#######end########"""
                            # redefine hs attributes 
                            # Start with half-saromere length
                            self.hs_length_list = self.mesh.hs_length_list
                            # Delta half-sarcomere length
                            self.delta_hs_length_list = np.zeros(self.local_n_of_int_points)
                            # Active stress generated by cross-bridge cycling of myosin
                            self.cb_stress_list = self.mesh.cb_stress_list
                            # Passive stress in half-sarcomeres
                            self.pass_stress_list = self.mesh.pass_stress_list

                            """ Generating half-sarcomere object list"""
                            for i in np.arange(self.local_n_of_int_points):
                                #""" Assign the hs length according to what used in the mesh"""
                                self.hs_objs_list[i].data['hs_length'] = \
                                    self.hs_length_list[i]
                                self.hs_objs_list[i].myof.y = \
                                    self.hs.myof.y
                                
                            """#######start########"""
                            y_vec = self.mesh.model['functions']['y_vec'].vector().array()[:]
                            if self.comm.Get_rank() == 0:
                                print 'y_vec in hs obj'
                                print self.hs_objs_list[0].myof.y
                                print 'y_vec in hs class' 
                                print self.hs.myof.y
                                
                            if self.comm.Get_rank() == 0:
                                print 'y_vec in meshclass'
                                print y_vec
                            """#######end########"""

                            # now reload back to ED vol in 10 steps
                            n_step = 10.0
                            loading_vol = ED_vol - self.reference_LV_vol
                            delta_vol = loading_vol / n_step
                            activation = 0
                            if self.comm.Get_rank() == 0:
                                print 'Diastolic loading/unloading ...'
                                #print 'Seting the LV cavity vol expression to be real current LV vol'
                            
                            #self.solver.solvenonlinear()
                            for n in range(int(n_step)):
                                expres_vol = self.mesh.model['functions']['LVCavityvol'].vol
                                if self.comm.Get_rank() == 0:
                                    print 'Inc vol: %f'%delta_vol
                                    print expres_vol

                                # solve hs to update y_vec while we are loading back to ED
                                for j in range(self.local_n_of_int_points):
                                    self.hs_objs_list[j].update_simulation(time_step,
                                                                            self.delta_hs_length_list[j], 
                                                                            activation,
                                                                            self.cb_stress_list[j],
                                                                            self.pass_stress_list[j])
                                    """if self.comm.Get_rank() == 0:
                                        print 'y_vec from hs obj class while reloading'
                                        print self.hs_objs_list[j].myof.y"""
                                    self.y_vec[j*self.y_vec_length+np.arange(self.y_vec_length)]= \
                                        self.hs_objs_list[j].myof.y[:]
                                    if j%1000==0 and self.comm.Get_rank() == 0:
                                        print '%.0f%% of integer points are updated' % (100*j/self.local_n_of_int_points)

                                self.mesh.model['functions']['y_vec'].vector()[:] = self.y_vec
                                y_vec = self.mesh.model['functions']['y_vec'].vector().array()[:]
                                if self.comm.Get_rank() == 0:
                                    print 'y_vec while reloading'
                                    print y_vec
                                self.mesh.model['functions']['hsl_old'].vector()[:] = self.hs_length_list

                                # Fill the LV with more blood
                                self.mesh.model['functions']['LVCavityvol'].vol += delta_vol
                                #lv_vol = self.mesh.model['functions']['LVCavityvol'].vol
                                lv_vol = self.mesh.model['uflforms'].LVcavityvol()
                                if self.comm.Get_rank() == 0:
                                    print 'Lv vol before solving %f' %lv_vol
                                
                                self.comm.Barrier()
                                self.solver.solvenonlinear()
                                lv_vol = self.mesh.model['uflforms'].LVcavityvol()
                                #remained_steps = n_step - (n+1)
                                if self.comm.Get_rank() == 0:
                                    print 'LV vol at step %d of loading/unloading is: %f' %(n,lv_vol)
                                
                                # update 
                                self.cb_stress_list = project(self.mesh.model['functions']['cb_stress'],
                                    self.mesh.model['function_spaces']['quadrature_space']).vector().get_local()[:]

                                self.mesh.model['functions']['hsl_old'].vector()[:] = \
                                    project(self.mesh.model['functions']['hsl'], 
                                    self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]

                                new_hs_length_list = \
                                    project(self.mesh.model['functions']['hsl'], 
                                    self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]

                                self.delta_hs_length_list = new_hs_length_list - self.hs_length_list
                                if self.comm.Get_rank() == 0:
                                    print 'delta hsl' 
                                    print self.delta_hs_length_list
                                self.hs_length_list = new_hs_length_list
                                
                                temp_DG = project(self.mesh.model['functions']['Sff'], 
                                            FunctionSpace(self.mesh.model['mesh'], "DG", 1), 
                                            form_compiler_parameters={"representation":"uflacs"})

                                p_f = interpolate(temp_DG, self.mesh.model['function_spaces']["quadrature_space"])
                                self.pass_stress_list = p_f.vector().get_local()[:]
                                
                                # Convert negative passive stress in half-sarcomeres to 0
                                self.pass_stress_list[self.pass_stress_list<0] = 0
                            
                                self.comm.Barrier()

                            """#######start########"""
                            #self.diastolic_loading(loading_vol)
                        
                            # reset y_vec back to its original value before growth

                            # solve with updted y_vec
                            hs_l = project(self.mesh.model['functions']['hsl'], 
                                    self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]
                            if self.comm.Get_rank() == 0:
                                print 'hsl after reloading'
                                print hs_l
                            #print 'solving weak form after reseting y_vec back to its original values'
                            #self.solver.solvenonlinear()
                            y_vec = self.mesh.model['functions']['y_vec'].vector().array()[:]
                            if self.comm.Get_rank() == 0:
                                print 'y_vec after reloading'
                                print y_vec
                            
                            lv_p = 0.0075*self.mesh.model['uflforms'].LVcavitypressure()
                            
                            if self.comm.Get_rank() == 0: 
                                print'lv press after reload back to ED'
                                print lv_p
                            # save LV geometry at ED 
                            file_path_ED = os.path.join(self.growth_path,'growth_ED' + str(self.data['time']) +'.xdmf') 
                            growth_mesh_ED = XDMFFile(mpi_comm_world(),file_path_ED)
                            growth_mesh_ED.parameters.update({"functions_share_mesh": True,
                                                        "rewrite_function_mesh": True})
                            growth_mesh_ED.write(self.mesh.model['mesh'])
                            """#######end########"""
                            # update the LV pressure in circultaion with new mesh 
                            self.circ.data['p'][-1] = \
                                0.0075*self.mesh.model['uflforms'].LVcavitypressure()
                        
                            self.gr.growth_frequency_n_counter = 0
                        
                        else:
                            self.gr.growth_frequency_n_counter += 1
                        
                        self.gr.initial_gr_cycle_counter += 1




############# testing Fr class



  # Check for fiber reorientation and implement  (data addressing should be checked)
        if (self.fr):
            self.data['fr_active'] = 0
            for f in self.prot.fiber_re_activations:
                if ((self.t_counter >= f.data['t_start_ind']) and
                        (self.t_counter < f.data['t_stop_ind'])):
                    self.data['fr_active'] = 1
                    if self.comm.Get_rank() == 0:
                        print("fiber reorientation active")




            if self.data['fr_active'] == 1:

                if self.comm.Get_rank() == 0:
                    print "updating fiber orientation"
                #deg = 2
                #VQuadelem = VectorElement("Quadrature", self.mesh.ufl_cell(), degree=deg, quad_scheme="default")
                #VQuadelem._quad_scheme = 'default'
                #fiberFS = FunctionSpace(self.mesh, VQuadelem)
    

                #PK2_passive = self.mesh.model['functions']['total_passive_PK2']
                #Pactive = self.mesh.model['functions']['Pactive']
                #total_stress = PK2_passive + Pactive
                #kappa = self.fr.data['time_constant']

                

                fdiff = self.fr.stress_law(self.fr.data['signal'],time_step,self.mesh.model['function_spaces']['fiber_FS'])

                temp_fiber = self.mesh.model['functions']['f0'].vector().get_local()[:]
                
                
                
                
                local_fdiff = fdiff.vector().get_local()[:]

                gdim2 = self.mesh.model['mesh'].geometry().dim()
                self.lcoord = self.mesh.model['function_spaces']['quadrature_space'].\
                tabulate_dof_coordinates().reshape((-1, gdim2))
                ### since stress is not realisic in base, we can exclude some basal points from fiber reoriantaion
                #print('point n', np.shape(self.lcoord[:,2]))  
                '''cnt =0 
                for i in np.arange(self.local_n_of_int_points):
                    if self.lcoord[i][2]< 0:
                        # wrong way: temp_fiber[i] += local_fdiff[i]
                        temp_fiber[ii*3:ii*3+3]+= local_fdiff[ii*3:ii*3+3]

                        cnt = cnt +1'''
                #print('point n', np.shape(self.lcoord[:,2]),'cnt', cnt)


                    
                ### all point FR
                temp_fiber += fdiff.vector().get_local()[:]

                self.mesh.model['functions']['f0'].vector()[:] = temp_fiber 


                s1 , n1 ,f1= self.fr.update_local_coordinate_system(self.mesh.model['functions']['f0'])
                
                self.mesh.model['functions']['s0'].vector()[:]=s1   ### on the left hand side get local is not needed as it can find the right place of the data in global function
                self.mesh.model['functions']['n0'].vector()[:]=n1
                self.mesh.model['functions']['f0'].vector()[:]=f1   ### f0  is being renormalized here after reorientation


                


                
                ##MM below parameters are calculated for post processing purposes
                #self.mesh.model['functions']["fdiff_mag"] = (sqrt((inner(fdiff,fdiff))))
                l_f0 = self.mesh.model['functions']['f0'].vector().get_local()[:] 
                ## important note: if we localize fiber data here as initial fiber it does not contain inital fiber as it is also updated automatically. initial fiber sould be localized out of time loop
                #l_`f00 `= self.mesh.model['functions']['f00'].vector().get_local()[:] 
                l_fdiff_ang = self.mesh.model['functions']["fdiff_ang"].vector().get_local()[:] 

                #print ("l_fdiff_ang=",l_fdiff_ang)
                
                for ii in np.arange(self.local_n_of_int_points):
                    
                    l_f0_holder = l_f0[ii*3:ii*3+3]
                    l_f00_holder = self.l_f00[ii*3:ii*3+3]
                    
                    cos = (np.inner(l_f0_holder,l_f00_holder))/(sqrt(np.inner(l_f0_holder,l_f0_holder))*sqrt(np.inner(l_f00_holder,l_f00_holder)))
                    cos = np.clip(cos, -1, 1)  #MM here avoids values abouve 1 cause nan results
                    rad = np.arccos(cos) 
                    theta = math.degrees(rad)
                    l_fdiff_ang[ii] = theta
                    #l_fdiff_ang[ii] = (180/3.14159)*np.arccos((np.inner(l_f0_holder,l_f00_holder))/(sqrt(np.inner(l_f0_holder,l_f0_holder))*sqrt(np.inner(l_f00_holder,l_f00_holder))))
                    
                
                self.mesh.model['functions']["fdiff_ang"].vector()[:] = l_fdiff_ang
                


                #self.mesh.model['functions']["f0_mag"] = (sqrt((inner(self.mesh.model['functions']['f0'],self.mesh.model['functions']['f0']))))
                #self.mesh.model['functions']["f00_mag"] = (sqrt((inner(self.mesh.model['functions']['f00'],self.mesh.model['functions']['f00']))))
                #self.mesh.model['functions']["fdiff_ang"] = (180/3.14159)*acos((inner(self.mesh.model['functions']['f0'],self.mesh.model['functions']['f00']))/(self.mesh.model['functions']["f0_mag"] *self.mesh.model['functions']["f00_mag"]  ))



                print "CHECKING NUMBER OF FIBER VECTORS"
                print np.shape(self.mesh.model['functions']['f0'].vector().get_local())
                print "Fiber orientation updated"
                
                
       


                ##MM to save the fiber even before fiber remodleing this apart needs to be out of if FR = 1
                #f0_vs_time_array = np.zeros((self.global_n_of_int_points,3,self.prot.data['no_of_time_steps']))
            
        #MM in kurtis code here f0 is being projected on fiber_FS. question: why is this needed as f0 is already on the fiber FS space
        #f0_vs_time_temp = project(self.mesh.model['functions']['f0'],self.mesh.model['function_spaces']['fiber_FS']).vector().get_local()[:]
        
        
#### below is one way of saving fiber data, which for now is not needed as we are saving fiber data in excell files as other params


        '''f0_vs_time_temp = self.mesh.model['functions']['f0'].vector().get_local()[:]
        f0_vs_time_temp2_global = self.comm.gather(f0_vs_time_temp)
                            
        if self.comm.Get_rank() == 0:

            
            f0_vs_time_temp2_global = np.concatenate(f0_vs_time_temp2_global).ravel()
            f0_vs_time_temp2_global = np.reshape(f0_vs_time_temp2_global,(self.global_n_of_int_points,3))

            self.f0_vs_time_array[:,:,self.t_counter] = f0_vs_time_temp2_global


            print "SAVING F0 VS TIME ARRAY"
            np.save(self.instruction_data["output_handler"]['mesh_output_path'][0]+"/f0_vs_time.npy",self.f0_vs_time_array)'''


        ##MM to save the data in case of failure, fiber data of all time steps is being saved here, later we can implement saveing freq

        #print "(self.f0_vs_time_array)"
        #for i in np.arange(100, 4000):
            #print (self.f0_vs_time_array[i,:,self.t_counter])
            
            #self.mesh.model['functions']['s0'],self.mesh.model['functions']['n0'] = self.fr.update_local_coordinate_system(self.mesh.model['functions']['f0']) 
            # lcs is not defined in the new platform and needs to be discussed


###################################

        

        self.update_data(time_step)
        if self.t_counter%self.dumping_data_frequency == 0:
            print 'Dumping data ...'
            if self.comm.Get_rank() == 0:
                self.write_complete_data_to_sim_data()

            # Now update local spatial data for each core
            self.write_complete_data_to_spatial_sim_data(self.comm.Get_rank())

            self.write_counter = self.write_counter + 1


            FE_DG0 = FiniteElement("DG",self.mesh.model['mesh'].ufl_cell(),0)
            FS_DG0 = FunctionSpace(self.mesh.model['mesh'],FE_DG0)
            
            # save data on mesh
            if self.mesh_obj_to_save:
                print 'Saving to 3d mesh'
                for m in self.mesh_obj_to_save:
                    if m == 'displacement':
                        temp_obj = self.mesh.model['functions']['w'].sub(0)
                        

                    if m == 'hs_length':
                        
                        temp_obj = project(self.mesh.model['functions']['hsl'], 

                                                self.mesh.model['function_spaces']["scalar"])
                        

                    if m in ['k_1','k_3','k_on','k_act','k_serca','cb_number_density']:
                            temp_obj = project(self.mesh.model['functions'][m], 
                                                self.mesh.model['function_spaces']["scalar"])
                            

                    if m in ['k_1_DG0']:
                            temp_obj = project(self.mesh.model['functions']["k_1"], 
                                                FS_DG0)
                            
                            
                    if m == 'cb_number_density_DG0':
                            temp_obj = project(self.mesh.model['functions']["cb_number_density"], 
                                                FS_DG0)

                    if m == 'cb_number_density':
                            temp_obj = project(self.mesh.model['functions']["cb_number_density"], 
                                                self.mesh.model['function_spaces']["scalar"])


                    if m == 'active_stress':
                        #inner_p = self.mesh.model['functions']['Pactive']
                        #temp_obj= project(inner_p,Vq,form_compiler_parameters={"representation":"uflacs"})
                        temp_obj = project(inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['Pactive']*
                                        self.mesh.model['functions']['f0']),self.mesh.model['function_spaces']["scalar"],
                                        form_compiler_parameters={"representation":"uflacs"})
                        
                    if m == 'active_stress_DG0':
                        temp_obj = project(inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['Pactive']*
                                        self.mesh.model['functions']['f0']),
                                        FS_DG0,form_compiler_parameters={"representation":"uflacs"})

                    if m == 'reorienting_angle':

                        #temp_obj = project(self.mesh.model['functions']['f0'],self.mesh.model['function_spaces']['fiber_FS'])  # should be checked: .vector().get_local()[:]   just added
                        finite_element_R0 = FiniteElement("DG",self.mesh.model['mesh'].ufl_cell(),0)
                        finite_elemet_R00 = FunctionSpace(self.mesh.model['mesh'],finite_element_R0)
                        temp_obj = project(self.mesh.model['functions']["fdiff_ang"],finite_elemet_R00)


                        
    
                    if m == 'c_param_DG0':



                        temp_obj = project(self.mesh.model['functions']['dolfin_functions']["passive_params"]["c"][-1],FS_DG0)
                        #File(self.instruction_data["output_handler"]['mesh_output_path'][0] + "c_param.pvd") << project(self.mesh.model['functions']['dolfin_functions']["passive_params"]["c"][-1],FunctionSpace(self.mesh.model['mesh'],"DG",0))

                    if m == 'c_param':


                        temp_obj = project(self.mesh.model['functions']['dolfin_functions']["passive_params"]["c"][-1],self.mesh.model['function_spaces']["scalar_CG"])
                        #File(self.instruction_data["output_handler"]['mesh_output_path'][0] + "c_param.pvd") << project(self.mesh.model['functions']['dolfin_functions']["passive_params"]["c"][-1],FunctionSpace(self.mesh.model['mesh'],"DG",0))

                    if m == 'fiber_direction':
                        
                        Velem0 = VectorElement("CG", self.mesh.model['mesh'].ufl_cell(), 1, quad_scheme="default")
                        Velem0._quad_scheme = 'default'
                        Velem_FS = FunctionSpace(self.mesh.model['mesh'],Velem0)
                        temp_obj = project(self.mesh.model['functions']['f0'],Velem_FS)

                    if m == 'endo_distance':

                        
                        temp_obj =  project(self.mesh.model['functions']['endo_dist'],self.mesh.model['function_spaces']["scalar"])
                               
                    if m == 'Transverse_Angle':

                        
                        temp = np.einsum('ij,ij->i',self.mesh.model['functions']['f0'].vector().array().reshape((-1,3)),self.mesh.model['functions']['ell'].vector().array().reshape((-1,3)))
                        temp2 = np.einsum('ij,ij->i',self.mesh.model['functions']['f0'].vector().array().reshape((-1,3)),self.mesh.model['functions']['ecc'].vector().array().reshape((-1,3)))
                        temp3 = np.einsum('ij,ij->i',self.mesh.model['functions']['f0'].vector().array().reshape((-1,3)),self.mesh.model['functions']['err'].vector().array().reshape((-1,3)))
                        self.TA.vector()[:] = (180/np.pi)*(np.arctan(temp3/temp2))

                        temp_obj =  project(self.TA,FS_DG0)


            
                    if m == 'Helical_Angle':

                        
                        temp = np.einsum('ij,ij->i',self.mesh.model['functions']['f0'].vector().array().reshape((-1,3)),self.mesh.model['functions']['ell'].vector().array().reshape((-1,3)))
                        temp2 = np.einsum('ij,ij->i',self.mesh.model['functions']['f0'].vector().array().reshape((-1,3)),self.mesh.model['functions']['ecc'].vector().array().reshape((-1,3)))
                        temp3 = np.einsum('ij,ij->i',self.mesh.model['functions']['f0'].vector().array().reshape((-1,3)),self.mesh.model['functions']['err'].vector().array().reshape((-1,3)))
                        self.HA.vector()[:]  = (180/np.pi)*(np.arctan(temp/temp2))

                        temp_obj =  project(self.HA,FS_DG0)



                        #dolfin.parameters["form_compiler"]["representation"] = "quadrature"
                    if m == 'total_stress':
                        temp_obj = project(inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['total_stress']*
                                        self.mesh.model['functions']['f0']),
                                        self.mesh.model['function_spaces']["scalar"],
                                        form_compiler_parameters={"representation":"uflacs"})

                    if m == 'total_stress_vector':

                            Velem0 = VectorElement("CG",self.mesh.model['mesh'].ufl_cell(), 1, quad_scheme="default")
                            Velem0._quad_scheme = 'default'
                            Velem_FS = FunctionSpace(self.mesh.model['mesh'],Velem0)
                            
                            temp_obj = project((self.mesh.model['functions']['total_stress']*self.mesh.model['functions']['f0']),Velem_FS,
                                        form_compiler_parameters={"representation":"uflacs"})
                            
                    if m == 'total_passive':
                        temp_obj = project(inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['total_passive_PK2']*
                                        self.mesh.model['functions']['f0']),
                                        self.mesh.model['function_spaces']["scalar_for_active"],
                                        form_compiler_parameters={"representation":"uflacs"})
                    if m == 'myofiber_passive':
                        temp_obj = project(inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['Sff']*
                                        self.mesh.model['functions']['f0']),
                                        self.mesh.model['function_spaces']["scalar_for_active"],
                                        form_compiler_parameters={"representation":"uflacs"})                    

                    
                            
                    if m in ['local_theta_vis_fiber','local_theta_vis_sheet','local_theta_vis_sheet_normal',
                                'global_theta_vis_fiber','global_theta_vis_sheet','global_theta_vis_sheet_normal',
                                'stimulus_fiber', 'stimulus_sheet', 'stimulus_sheet_normal',
                                'deviation_fiber', 'deviation_sheet','deviation_sheet_normal',
                                'setpoint_fiber','setpoint_sheet','setpoint_sheet_normal'] and \
                                    'growth' in self.instruction_data['model']:

                            temp_obj = project(self.mesh.model['functions'][m],
                                                self.mesh.model['function_spaces']["scalar_for_growth"],
                                                form_compiler_parameters={"representation":"uflacs"})


                    temp_obj.rename(m,'')
                    
                    self.solution_mesh.write(temp_obj,self.data['time'])
                    

        # Update the t counter for the next step
        self.t_counter = self.t_counter + 1
        self.data['time'] = self.data['time'] + time_step


        '''if self.t_counter == (self.prot.data['no_of_time_steps']-1): # at last time step
            print "LAST TIME STEP, SAVE F0_VS_TIME"
            # save full f0_vs_time
            #if 'kroon_time_constant' in locals():
            if 'fiber_direction' in self.mesh_obj_to_save:
           
                print "SAVING F0 VS TIME ARRAY"
                np.save(self.instruction_data["output_handler"]['mesh_output_path'][0]+"f0_vs_time.npy",f0_vs_time_array)
                self.instruction_data'''

        
        self.data['new_beat'] = new_beat


    def update_data(self, time_step):
        """ Update data after a time step """

        # Update data for the heart-rate
        self.data['heart_rate'] = self.hr.return_heart_rate()

        
        self.circ.updata_data(time_step)

    def return_system_values(self, time_interval=0.01):
        d = dict()
        vol = dict()
        pres = dict()
        flow = dict()
        vol['volume_ventricle'] = self.circ.data['v'][-1]
        vol['volume_aorta'] = self.circ.data['v'][0]
        vol['volume_arteries'] = self.circ.data['v'][1]
        vol['volume_arterioles'] = self.circ.data['v'][2]
        vol['volume_capillaries'] = self.circ.data['v'][3]
        vol['volume_venules'] = self.circ.data['v'][4]
        vol['volume_veins'] = self.circ.data['v'][5]

        pres['pressure_ventricle'] = self.circ.data['p'][-1]
        pres['pressure_aorta'] = self.circ.data['p'][0]
        pres['pressure_arteries'] = self.circ.data['p'][1]
        pres['pressure_arterioles'] = self.circ.data['p'][2]
        pres['pressure_capillaries'] = self.circ.data['p'][3]
        pres['pressure_venules'] = self.circ.data['p'][4]
        pres['pressure_veins'] = self.circ.data['p'][5]

        flow['flow_ventricle_to_aorta'] = self.circ.data['f'][0]
        flow['flow_aorta_to_arteries'] = self.circ.data['f'][1]
        flow['flow_arteries_to_arterioles'] = self.circ.data['f'][2]
        flow['flow_arterioles_to_capillaries'] = self.circ.data['f'][3]
        flow['flow_capillaries_to_venules'] = self.circ.data['f'][4]
        flow['flow_venules_to_veins'] = self.circ.data['f'][5]
        flow['flow_veins_to_ventricle'] = self.circ.data['f'][6]
        

        """if (self.data['time'] > time_interval):
            self.temp_data = \
                self.sim_data[self.sim_data['time'].between(
                    self.data['time']-time_interval, self.data['time'])]

            d['volume_ventricle_max'] = \
                self.temp_data['volume_ventricle'].max()
            d['stroke_volume'] = d['volume_ventricle_max'] - \
                self.temp_data['volume_ventricle'].min()
            d['pressure_ventricle'] = self.temp_data['pressure_ventricle'].mean()
            #d['ejection_fraction'] = self.temp_data['ejection_fraction'].mean()
            d['heart_rate'] = self.data['heart_rate']
            d['cardiac_output'] = d['stroke_volume'] * d['heart_rate']"""
           
            
        return vol, pres,flow

    def write_complete_data_to_sim_data(self):
        """ Writes full data to data frame """
        
    

        for f in list(self.data.keys()):


            if f not in ['Sff','sff_mean','hsl','alpha_f','total_stress_spatial','fr_active']:
                self.sim_data[f][self.write_counter] = self.data[f]

        for f in list(self.circ.data.keys()):
            if (f not in ['p', 'v', 's', 'compliance', 'resistance',
                            'inertance', 'f']):
                self.sim_data[f][self.write_counter] = self.circ.data[f]
        for f in list(self.hr.data.keys()):
            self.sim_data[f][self.write_counter] = self.hr.data[f]

        if (self.br):
            for f in list(self.br.data.keys()):
                self.sim_data[f][self.write_counter] = self.br.data[f]
        if (self.gr):
            for f in list(self.gr.data.keys()):

                
        #if (self.fr):
            #for f in list(self.fr.data.keys()):
                #self.sim_data[f][self.write_counter] = self.fr.data[f]



                if f not in self.spatial_gr_data_fields:
                    self.sim_data[f][self.write_counter] = self.gr.data[f]

    
        self.sim_data['write_mode'] = 1
        

    def write_complete_data_to_spatial_sim_data(self,rank):

        print 'Writing spatial variables on core id: %0.0f' %rank

        if self.spatial_data_to_mean:

            self.local_spatial_sim_data.at[self.write_counter,'time'] = self.data['time']

            for f in list(self.spatial_hs_data_fields):
                data_field = []
                for i,h in enumerate(self.hs_objs_list):
                    data_field.append(h.data[f]) 
                self.local_spatial_sim_data.at[self.write_counter,f] = np.mean(data_field)

            

            for f in list( self.spatial_myof_data_fields):
                data_field = []
                for h in self.hs_objs_list:
                    data_field.append(h.myof.data[f]) 
                self.local_spatial_sim_data.at[self.write_counter,f] = np.mean(data_field)
            
            


            for f in list(self.spatial_memb_data_fields):
                data_field = []
                for h in self.hs_objs_list:
                    data_field.append(h.memb.data[f]) 
                self.local_spatial_sim_data.at[self.write_counter,f] = np.mean(data_field)


           
           
            '''for f in list(self.spatial_fiber_data_fields):
                data_field = []

                if f == 'f01':
                    d = self.mesh.model['functions']['f0'].vector().get_local()[:,1]
                    data_field.append(d)

                #for i,d in enumerate(self.mesh.model['functions']['f0'].vector().get_local()[:,1]):
                   # data_field.append(d)
                self.local_spatial_sim_data.at[self.write_counter,f] = np.mean(data_field)'''

            #self.mesh.data['f0'] = array

            
            

            
            if self.gr:
                for f in list(self.spatial_gr_data_fields):
                    data_field = self.gr.data[f]
                    self.local_spatial_sim_data.at[self.write_counter,f] = np.mean(data_field)
            
            for f in ['Sff','sff_mean','alpha_f']:
                data_field = self.data[f]
                self.local_spatial_sim_data.at[self.write_counter,f] = np.mean(data_field)


        else:

            

            for f in self.spatial_hs_data_fields:
                data_field = []
                for h in self.hs_objs_list:
                    data_field.append(h.data[f])
                self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
                #self.local_spatial_sim_data[f].at[self.write_counter,'time'] = \
                #    self.data['time']

            for f in self.spatial_myof_data_fields:
                data_field = []
                for h in (self.hs_objs_list):
                    data_field.append(h.myof.data[f])
                self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
                #self.local_spatial_sim_data[f].at[self.write_counter,'time'] = \
                #    self.data['time']
            
            for f in self.spatial_memb_data_fields:
                data_field = []
                for h in list(self.hs_objs_list):
                    #print("h check",np.shape(h.memb.data[f]))
                    data_field.append(h.memb.data[f])
                self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
            
            
                #self.local_spatial_sim_data[f].at[self.write_counter,'time'] = \
                #    self.data['time']
            if self.gr:
                for f in self.spatial_gr_data_fields:
                    data_field = self.gr.data[f]
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
            
            for f in ['Sff','sff_mean','alpha_f']:
                data_field = self.data[f]
                self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field



            f0_temp = self.mesh.model['functions']['f0'].vector().get_local()[:]
            f0_temp_3n = np.reshape(f0_temp,(self.local_n_of_int_points,3))
            f0_x = f0_temp_3n[:,0]
            f0_y = f0_temp_3n[:,1]
            f0_z = f0_temp_3n[:,2]

            gdim2 = self.mesh.model['mesh'].geometry().dim()

            self.lcoord = self.mesh.model['function_spaces']['quadrature_space'].\
                tabulate_dof_coordinates().reshape((-1, gdim2))
            lx = self.lcoord[:,0]
            ly = self.lcoord[:,1]
            lz = self.lcoord[:,2]

            endo_dist = self.mesh.model['functions']['endo_dist'].vector().get_local()[:]
            fr_angle = self.mesh.model['functions']["fdiff_ang"].vector().get_local()[:]

            ecc_temp = self.mesh.model['functions']['ecc'].vector().get_local()[:]
            ecc_temp_3n = np.reshape(ecc_temp,(self.local_n_of_int_points,3))
            ecc_x = ecc_temp_3n[:,0]
            ecc_y = ecc_temp_3n[:,1]
            ecc_z = ecc_temp_3n[:,2]


            err_temp= self.mesh.model['functions']['err'].vector().get_local()[:]
            err_temp_3n = np.reshape(err_temp,(self.local_n_of_int_points,3))
            err_x = err_temp_3n[:,0]
            err_y = err_temp_3n[:,1]
            err_z = err_temp_3n[:,2]



            ell_temp= self.mesh.model['functions']['ell'].vector().get_local()[:]
            ell_temp_3n = np.reshape(ell_temp,(self.local_n_of_int_points,3))
            ell_x = ell_temp_3n[:,0]
            ell_y = ell_temp_3n[:,1]
            ell_z = ell_temp_3n[:,2]

            
            for f in self.spatial_fiber_data_fields:
                data_field = []

                

                if f == 'f01':

                    
                    data_field= list(f0_x)

                    self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field

                if f == 'f02':
                    data_field= list(f0_y)
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
                if f == 'f03':
                    data_field= list(f0_z)
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field


                if f == 'fr_angle':
                    data_field= list(fr_angle)
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
#### here we need to save the geometric data of fibers based on the number of cores similar to other modeling params


                if self.write_counter==1:
                    if f == 'lx':
                        data_field= list(lx)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field


                    if f == 'ly':
                        data_field= list(ly)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field

                    if f == 'lz':
                        data_field= list(lz)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field


                    if f == 'endo_dist':
                        data_field= list(endo_dist)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field


                    #self.local_spatial_sim_data[f].at[self.write_counter,'time'] = \
                    #    self.data['time'
                    
                    if f == 'eccx':
                        data_field= list(ecc_x)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
                    if f == 'eccy':
                        data_field= list(ecc_y)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
                    if f == 'eccz':
                        data_field= list(ecc_z)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field    

                    if f == 'errx':
                        data_field= list(err_x)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
                    if f == 'erry':
                        data_field= list(err_y)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
                    if f == 'errz':
                        data_field= list(err_z)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field

                    if f == 'ellx':
                        data_field= list(ell_x)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
                    if f == 'elly':
                        data_field= list(ell_y)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
                    if f == 'ellz':
                        data_field= list(ell_z)
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                        self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field

            
            



            temp0  = inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['Pactive']*
                                        self.mesh.model['functions']['f0'])
            temp= project(temp0,self.mesh.model['function_spaces']["quadrature_space"])        
            active_stress = temp.vector().get_local()[:]



            
            temp = inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['passive_total_stress']*
                                        self.mesh.model['functions']['f0'])
            
            #total_passive = temp.vector().get_local()[:]
            total_passive = project(temp,self.mesh.model['function_spaces']["scalar"],form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]

            #total_passive = interpolate(temp_DG, self.mesh.model['function_spaces']["quadrature_space"])



            #total_passive = project(temp,self.mesh.model['function_spaces']["quadrature_space"],form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]
        





            
            temp = inner(self.mesh.model['functions']['f0'],
                        self.mesh.model['functions']['myo_passive_PK2']*
                        self.mesh.model['functions']['f0'])
            
            myofiber_passive = project(temp,
                                        self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]

            #myo_FS = Function(self.mesh.model['function_spaces']['quadrature_space'])
            
            myo_Sff = project(self.mesh.model['functions']['Sff'],
                              self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]
          

            print("1")
            temp = inner(self.mesh.model['functions']['f0'],
                        self.mesh.model['functions']['bulk_passive']*
                        self.mesh.model['functions']['f0'])
            bulk_passive = project(temp,
                    self.mesh.model['function_spaces']["scalar"],form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]
            print("2")
            temp = inner(self.mesh.model['functions']['f0'],
                        self.mesh.model['functions']['incomp_stress']*
                        self.mesh.model['functions']['f0'])
            print("3")
            incomp_stress = project(temp,
                    self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]
            print("4")



            for f in self.spatial_extra:
                data_field = []


                if f == 'active_stress':
                    
                    data_field= list(active_stress)
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field


                if f == 'total_passive':
                    data_field= list(total_passive)
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field


                if f == 'myofiber_passive':
                    data_field= list(myofiber_passive)
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field

                
                if f == 'Sff_mesh':

                    data_field = list(myo_Sff)
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])

                    self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
            
                if f == 'bulk_passive':

                    data_field = list(bulk_passive)
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
            
                if f == 'incomp_stress':

                    data_field = list(incomp_stress)
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = map(float, self.local_spatial_sim_data[f].iloc[self.write_counter])
                    self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
            

    def check_output_directory_folder(self, path=""):
        """ Check output folder"""
        output_dir = os.path.dirname(path)
        print('output_dir %s' % output_dir)
        if not os.path.isdir(output_dir):
            print('Making output dir')
            os.makedirs(output_dir)

    def handle_output(self, output_struct):
        """ Handle output data"""
        if self.comm.Get_size() > 1:
            # first send all local spatial data to root core (i.e. 0)
            if self.comm.Get_rank() != 0 :
                self.comm.send(self.local_spatial_sim_data,dest = 0,tag = 2)

           # let root core recieve them
            if self.comm.Get_rank() == 0:
                temp_data_holders = []
                temp_data_holders.append(self.local_spatial_sim_data)
                # recieve local data from others 
                for i in range(1,self.comm.Get_size()):
                    temp_data_holders.append(self.comm.recv(source = i, tag = 2))
                # now dump them to global data holders
                print 'Spatial variables are being gathered from multiple computing cores'
                if self.spatial_data_to_mean:
                    for c in self.spatial_sim_data.columns:
                        self.spatial_sim_data[c] = \
                            sum([temp_data_holders[i][c]*self.int_points_per_core[i] for i \
                                in range(len(self.int_points_per_core))])/np.sum(self.int_points_per_core)
                else:
                    for j,f in enumerate(list(self.spatial_sim_data.keys())):
                        print '%.0f%% complete' %(100*j/len(list(self.spatial_sim_data.keys())))
                        for id in range(0,self.comm.Get_size()):
                            #i_0 = np.sum(self.int_points_per_core[0:id])
                            #i_1 = i_0 + self.int_points_per_core[id]
                            #cols = np.arange(i_0,i_1)
                            cols = self.dofmap_list[id]
                            self.spatial_sim_data[f][cols] = \
                                temp_data_holders[id][f]
                        
                        self.spatial_sim_data[f]['time'] = self.sim_data['time']

        else:
            self.spatial_sim_data = self.local_spatial_sim_data
        # Now save output data
        # Things to improve: 1) Different data format (e.g. csv, hdf5, etc)
        # 2) Store data at a specified resolution (e.g. every 100 time steps)
        if output_struct and self.comm.Get_rank() == 0:
            if self.output_data_str:
                output_sim_data = pd.DataFrame(data = self.sim_data)
                output_sim_data.to_csv(self.output_data_str)
                #self.sim_data.to_csv(self.output_data_str)

                output_dir = os.path.dirname(self.output_data_str)
                if self.spatial_data_to_mean:
                    out_path = output_dir + '/' + 'spatial_data.csv'
                    self.spatial_sim_data.to_csv(out_path)
                else:
                    for f in list(self.spatial_sim_data.keys()):
                        out_path = output_dir + '/' + f + '_data.csv'
                        self.spatial_sim_data[f].to_csv(out_path)

                    '''out_path = output_dir + '/'  + 'coord_data.csv'
                    coord = list(self.coord)
                    coord.to_csv(out_path)'''
        
        if self.comm.Get_rank() == 0:
            print("Out_path:",out_path)

        return 
    def rebuild_from_perturbations(self):
        """ builds system arrays that could change during simulation """

        for i, v in enumerate(self.circ.model['compartment_list']):
            r = self.circ.data[('%s_resistance' % v)]
            self.circ.data['resistance'][i] = r

        for i, v in enumerate(self.circ.model['compartment_list']):
            if (i < (self.circ.model['no_of_compartments']-1)):
                c = self.circ.data[('%s_compliance' % v)]
                self.circ.data['compliance'][i] = c

    def return_spherical_radius(self,xc,yc,zc,x,y,z):

        return ((xc-x)**2+(yc-y)**2+(zc-z)**2)**0.5 
    
    def return_cylindrical_radius(self,yc,zc,y,z):

        return ((yc-y)**2+(zc-z)**2)**0.5 

    def initialize_dof_mapping(self):
        
        """Lets handle dof mapping for quadrature points """
        if self.comm.Get_rank() == 0:
            print 'Initializing dof mapping'
        self.dofmap_list = []
        self.dofmap = self.mesh.model['function_spaces']['quadrature_space'].dofmap().dofs()
        
        # Send dof mapping and list of coords to root core (i.e. 0)
        if self.comm.Get_rank() != 0:
            self.comm.send(self.dofmap,dest = 0, tag = 0)
        else: # Root core recieves  from other cores
            self.dofmap_list.append(self.dofmap)
            for i in range(1,self.comm.Get_size()):
                self.dofmap_list.append(self.comm.recv(source = i, tag = 0))
        # Now broadcast the list to all cores
        self.dofmap_list = \
            self.comm.bcast(self.dofmap_list)
    
    def initialize_integer_points(self):

        if self.comm.Get_rank() == 0:
            print 'Initializing integer points on each core.'
        # half_sarcomere parameters spatially 
        # 4 comes from using degree 2
        #self.hs_params_mesh = dict()
        self.local_n_of_int_points = \
            4 * np.shape(self.mesh.model['mesh'].cells())[0]
        
        """ Calculate the total no of integration points"""
        # First on the root core
        self.global_n_of_int_points = \
            self.comm.reduce(self.local_n_of_int_points)
        # Then broadcast to all other cores
        self.global_n_of_int_points = \
            self.comm.bcast(self.global_n_of_int_points)

        """ Now generate a list (with len = total num of cores) """
        # that holds the num of integer points for each core
        self.int_points_per_core = \
                np.zeros(self.comm.Get_size())
        # Send local num of integer points to root core (i.e. 0)
        if self.comm.Get_rank() != 0:
            self.comm.send(self.local_n_of_int_points,dest = 0, tag = 1)
        else: # Root core recieves local num of int points from other cores
            self.int_points_per_core[0] = self.local_n_of_int_points
            for i in range(1,self.comm.Get_size()):
                self.int_points_per_core[i] = \
                    self.comm.recv(source = i, tag = 1)
        # Now broadcast the list to all cores
        self.int_points_per_core = \
            self.comm.bcast(self.int_points_per_core)

        if self.comm.Get_rank() == 1:
            print 'Total no if int points is %0.0f'\
                %self.global_n_of_int_points
            
    def handle_coordinates_of_geometry(self):

        """ Handle the coordinates of quadrature (integer) points"""
        gdim = self.mesh.model['mesh'].geometry().dim()

        self.coord = self.mesh.model['function_spaces']['quadrature_space'].\
                tabulate_dof_coordinates().reshape((-1, gdim))
        if self.comm.Get_rank()!=0:
                self.comm.send(self.coord,dest=0,tag = 3)
        else:
            for i in range(1,self.comm.Get_size()):
                self.coord = \
                        np.append(self.coord,
                            self.comm.recv(source = i, tag = 3),axis = 0)
        
        self.coord = self.comm.bcast(self.coord)

        """Handle the coordinates """
        x_coord = []
        y_coord = []
        z_coord = []
        for i, c in enumerate(self.coord):
            x_coord.append(c[0])
            y_coord.append(c[1])
            z_coord.append(c[2])

        self.x_coord = np.array(x_coord)
        self.y_coord = np.array(y_coord)
        self.z_coord = np.array(z_coord)

        print 'dimensions of LV'
        print self.z_coord.min()
        print self.x_coord.max()
    
    def handle_apex_contractility(self,instruction_data):

        """ Reduce the contractility of gaussian points near apex"""
        # First assume the corrdinates of apex
        xc = 0.0
        yc = 0.0
        zc = self.z_coord.min()
        if self.comm.Get_rank()==0:
            print 'Z of apex:'
            print zc

        # then calculate the distance of all gaussian points wrt apex
        self.apex_r = []
        for i,p in enumerate(self.z_coord):
            self.apex_r.append(self.return_spherical_radius(xc,yc,zc,
                                self.x_coord[i],self.y_coord[i],self.z_coord[i]))
        self.apex_r = np.array(self.apex_r)
        
        #now build an array for storing radius of apex for local integer points
        self.apex_r_local = np.zeros(self.local_n_of_int_points)
        for i,j in enumerate(self.dofmap):
            self.apex_r_local[i] = self.apex_r[j]

        # Now start selecting the points and change the active properties
        if 'apex_contractility' in instruction_data['mesh']:
            apex_components = []
            for ci,comp in enumerate(instruction_data['mesh']['apex_contractility']['components']):
                apex_components.append(dict())
                for k in comp.keys():
                    apex_components[ci][k] = comp[k][0]
            
                # then apply
                indicies = np.where(self.apex_r<self.apex_r.max()*\
                    apex_components[ci]['radius_ratio'])

                mask = np.isin(self.dofmap,indicies)
                hs_list = np.array(self.hs_objs_list)

                for i,j  in enumerate(hs_list[mask]):
                    r = self.apex_r_local[mask][i]
                    if apex_components[ci]['level']=='myofilaments':
                        #j.myof.data[apex_components[ci]['variable']] *= \
                        #    apex_components[ci]['factor']
                        p = j.myof.data[apex_components[ci]['variable']]
                        j.myof.data[apex_components[ci]['variable']] = \
                            p * (1-apex_components[ci]['factor']) * r / \
                                (self.apex_r.max()*apex_components[ci]['radius_ratio']) + \
                                   p * apex_components[ci]['factor']
                    elif apex_components[ci]['level']=='memberanes':
                        #j.memb.data[apex_components[ci]['variable']] *= \
                        #    apex_components[ci]['factor']
                        p = j.memb.data[apex_components[ci]['variable']]
                        j.memb.data[apex_components[ci]['variable']] = \
                            p * (1-apex_components[ci]['factor']) * r / \
                                (self.apex_r.max()*apex_components[ci]['radius_ratio']) + \
                                   p * apex_components[ci]['factor']
    
    def handle_hs_visualization_on_mesh(self):

        # assign the values from the half-sarcomere isntances
        # to spatial variables that baroreflex can regulate
        # (for visualizaton purpose)
        for p in ['k_1','k_3','k_on'] :
            for i, h in enumerate(self.hs_objs_list):
                self.mesh.data[p][i] = h.myof.data[p]
            self.mesh.model['functions'][p].vector()[:] = \
                  self.mesh.data[p]
        for p in ['k_act','k_serca']:
            for i, h in enumerate(self.hs_objs_list):
                self.mesh.data[p][i] = h.memb.data[p]
            self.mesh.model['functions'][p].vector()[:] = \
                  self.mesh.data[p]

    def handle_infarct(self,infarct_struct):


        ### note MM: here we can assign the acute MI since it can start at any time. for chronic MI we use het function as an initialization 

        self.infarct_model = dict()
        for inf in infarct_struct.keys():
            self.infarct_model[inf] = infarct_struct[inf][0]
        #define the initial point of infarcted region 
        y_m = 0
        z_m = self.z_coord.min() * self.infarct_model['z_ratio']
        z_m_upper = z_m * 0.99
        z_m_lower = z_m * 1.01

        x_mid_vent_slice = \
            self.x_coord[np.where((self.z_coord>=z_m_lower)&\
                        (self.z_coord<=z_m_upper))]
        x_m = x_mid_vent_slice.max()


        radius = []



        for i,p in enumerate(self.z_coord):
            radius.append(self.return_spherical_radius(x_m,y_m,z_m,
                                    self.x_coord[i],
                                    self.y_coord[i],
                                    self.z_coord[i]))
        radius = np.array(radius)






        local_points_r = np.zeros(self.local_n_of_int_points)
        for i,j in enumerate(self.dofmap):
            local_points_r[i] = radius[j]

        infarct_regions = np.where(local_points_r<=self.infarct_model['infarct_radius'])[0]
        border_zone_regions = \
            np.where((local_points_r >= self.infarct_model['infarct_radius']) &\
                    (local_points_r <= self.infarct_model['boundary_zone_radius']))[0]
        
        return infarct_regions, border_zone_regions
    
